"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/modules/[moduleId]/[topicId]/page",{

/***/ "(app-pages-browser)/./src/lib/topicData.ts":
/*!******************************!*\
  !*** ./src/lib/topicData.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   topicData: function() { return /* binding */ topicData; }\n/* harmony export */ });\nconst topicData = {\n    what_is_pandas: {\n        id: \"what_is_pandas\",\n        title: \"What is Pandas\",\n        type: \"theory\",\n        content: {\n            explanation: 'Pandas is a powerful, open-source data analysis and manipulation library for Python. Built on top of NumPy, it provides high-performance, easy-to-use data structures and data analysis tools.\\n\\n\\uD83C\\uDFAF **What makes Pandas special?**\\n\\nPandas stands for \"Panel Data\" and was originally developed by Wes McKinney in 2008. It has become the cornerstone of data analysis in Python because it makes working with structured data intuitive and efficient.\\n\\n**Key Capabilities:**\\n• Data Structures: Two primary data structures - Series (1D) and DataFrame (2D)\\n• Data Import/Export: Read from CSV, Excel, JSON, SQL databases, web APIs, and more\\n• Data Cleaning: Handle missing data, remove duplicates, transform data types\\n• Data Manipulation: Filter, sort, group, merge, and reshape data with ease\\n• Statistical Analysis: Built-in statistical functions and time series analysis\\n• Visualization: Basic plotting capabilities with matplotlib integration\\n\\n**Why Pandas is Essential:**\\nPandas bridges the gap between raw data and analysis. Before pandas, working with structured data in Python required writing lots of boilerplate code. Pandas provides intuitive, readable syntax that makes data analysis accessible to everyone.\\n\\n**Industries Using Pandas:**\\n• Finance - Risk analysis, portfolio optimization, trading algorithms\\n• Healthcare - Patient data analysis, medical research, clinical trials\\n• Marketing - Customer segmentation, campaign analysis, A/B testing  \\n• Technology - Log analysis, user behavior tracking, system monitoring\\n• Research - Scientific data analysis, academic research, data journalism',\n            codeExample: \"```python\\n# Import pandas - the standard way\\nimport pandas as pd\\nimport numpy as np\\n\\n# Create your first DataFrame\\ndata = {\\n    'Product': ['Laptop', 'Phone', 'Tablet', 'Monitor'],\\n    'Price': [999.99, 699.99, 399.99, 299.99],\\n    'Category': ['Electronics', 'Electronics', 'Electronics', 'Electronics'],\\n    'In_Stock': [True, True, False, True],\\n    'Rating': [4.5, 4.2, 4.0, 4.8]\\n}\\n\\ndf = pd.DataFrame(data)\\nprint(\\\"Your First DataFrame:\\\")\\nprint(df)\\nprint(f\\\"DataFrame Shape: {df.shape}\\\")\\nprint(f\\\"Data Types:\\\\n{df.dtypes}\\\")\\n\\n# Create a Series (1D data structure)\\nprices = pd.Series([999.99, 699.99, 399.99, 299.99], \\n                   name='Prices',\\n                   index=['Laptop', 'Phone', 'Tablet', 'Monitor'])\\nprint(f\\\"Prices Series:\\\\n{prices}\\\")\\n\\n# Quick DataFrame statistics\\nprint(f\\\"Quick Statistics:\\\\n{df.describe()}\\\")\\n```\",\n            practicalExercise: \"\\uD83C\\uDFAF **Your First Pandas Challenge:**\\n\\nCreate a DataFrame about your favorite movies:\\n\\n1. Create a dictionary with these columns:\\n   - 'Title': Names of 5 movies you love\\n   - 'Year': Release years  \\n   - 'Genre': Movie genres\\n   - 'Rating': Your personal rating (1-10)\\n   - 'Watched': True/False if you've watched recently\\n\\n2. Convert it to a DataFrame using pd.DataFrame()\\n3. Print the DataFrame\\n4. Print the shape and data types\\n5. Calculate the average rating using df['Rating'].mean()\\n\\n**Bonus Challenge:**\\nCreate a Series of movie directors and explore its properties!\",\n            keyPoints: [\n                \"Pandas is built on NumPy, making it fast and efficient for numerical operations\",\n                \"Two main data structures: Series (1D) and DataFrame (2D) handle most data scenarios\",\n                \"Pandas excels at data import/export with support for 10+ file formats\",\n                \"Built-in functions for data cleaning, transformation, and statistical analysis\",\n                \"Essential tool in data science workflow - from raw data to insights\",\n                \"Developed by Wes McKinney in 2008, now maintained by large open-source community\",\n                \"Integrates seamlessly with matplotlib, scikit-learn, and other Python libraries\"\n            ],\n            quiz: {\n                question: \"What are the two primary data structures in pandas?\",\n                options: [\n                    \"List and Dictionary\",\n                    \"Series and DataFrame\",\n                    \"Array and Matrix\",\n                    \"Table and Column\"\n                ],\n                correct: 1\n            }\n        }\n    },\n    installation_setup: {\n        id: \"installation_setup\",\n        title: \"Installation and Setup\",\n        type: \"practical\",\n        content: {\n            explanation: \"Getting pandas installed and configured properly is crucial for a smooth data analysis experience. Let's explore different installation methods and set up your environment.\\n\\n\\uD83D\\uDD27 **Installation Methods:**\\n\\n**Method 1: pip (Python Package Installer)**\\nThe most straightforward method for most users. pip comes with Python 3.4+ by default.\\n\\n**Method 2: conda (Anaconda/Miniconda)** Recommended for data science work. Conda manages dependencies better and includes optimized numerical libraries.\\n\\n**Method 3: Full Anaconda Distribution**\\nComplete data science environment with 250+ packages pre-installed.\\n\\n\\uD83D\\uDD0D **Verification Steps:**\\nAfter installation, always verify that pandas is working correctly and check the version.\\n\\n\\uD83D\\uDE80 **Development Environment Setup:**\\nFor the best pandas experience, consider setting up:\\n• Jupyter Notebook/Lab: Interactive development environment\\n• IDE Configuration: VS Code, PyCharm, or Spyder with pandas support\\n• Virtual Environments: Isolate your pandas projects\\n\\n\\uD83D\\uDCE6 **Additional Packages:**\\nWhile pandas is powerful alone, these packages enhance your data analysis:\\n• NumPy: Numerical operations (automatically installed with pandas)\\n• Matplotlib: Data visualization  \\n• Seaborn: Statistical data visualization\\n• Openpyxl: Excel file support\\n• SQLAlchemy: Database connectivity\",\n            codeExample: '**Installation Commands (run in terminal/command prompt):**\\n\\n```bash\\n# Method 1: Using pip\\npip install pandas\\n\\n# Install pandas with additional data science packages\\npip install pandas numpy matplotlib seaborn jupyter openpyxl\\n\\n# Method 2: Using conda (recommended for data science)\\nconda install pandas\\n\\n# Install from conda-forge (often more up-to-date)\\nconda install -c conda-forge pandas\\n\\n# Method 3: Create a new conda environment with pandas\\nconda create -n data_analysis python=3.9 pandas numpy matplotlib jupyter\\nconda activate data_analysis\\n\\n# Upgrade existing pandas installation\\npip install --upgrade pandas\\n# or\\nconda update pandas\\n```\\n\\n**Verification Code (run in Python):**\\n\\n```python\\nimport pandas as pd\\nimport numpy as np\\nimport sys\\n\\nprint(\"\\uD83D\\uDC0D Python Version:\", sys.version)\\nprint(\"\\uD83D\\uDC3C Pandas Version:\", pd.__version__)\\nprint(\"\\uD83D\\uDD22 NumPy Version:\", np.__version__)\\n\\n# Test basic functionality\\ntest_data = {\\'A\\': [1, 2, 3], \\'B\\': [4, 5, 6]}\\ndf = pd.DataFrame(test_data)\\nprint(\"\\\\n✅ Pandas is working correctly!\")\\nprint(df)\\n\\n# Check available pandas functions\\nprint(f\"\\\\n\\uD83D\\uDCCA Available pandas functions: {len(dir(pd))} total\")\\n\\n# Display pandas configuration\\nprint(\"\\\\n⚙️ Pandas Configuration:\")\\npd.show_versions(as_json=False)\\n```',\n            practicalExercise: '\\uD83D\\uDEE0️ **Installation Practice:**\\n\\n**Step 1: Install pandas**\\nChoose your preferred method and install pandas\\n\\n**Step 2: Verify Installation**\\nRun the verification code to check everything works\\n\\n**Step 3: Set Up Your Environment**\\n1. Install Jupyter: `pip install jupyter`\\n2. Launch Jupyter: `jupyter notebook`\\n3. Create a new notebook called \"Pandas_Practice\"\\n\\n**Step 4: Environment Test**\\nIn your new notebook:\\n1. Import pandas and numpy\\n2. Create a small DataFrame with sample data\\n3. Perform a simple operation (like calculating mean)\\n4. Display the result\\n\\n**Troubleshooting Common Issues:**\\n• Permission errors: Try `pip install --user pandas`\\n• Version conflicts: Use virtual environments\\n• ImportError: Restart your Python environment after installation',\n            keyPoints: [\n                \"pip install pandas is the quickest method for most users\",\n                \"conda is recommended for data science due to better dependency management\",\n                \"Always verify installation by importing pandas and checking version\",\n                \"Jupyter Notebook provides excellent interactive environment for pandas\",\n                \"Virtual environments prevent package conflicts in different projects\",\n                \"Keep pandas updated with regular pip/conda upgrade commands\",\n                \"Install additional packages (matplotlib, seaborn) for complete data analysis toolkit\"\n            ],\n            quiz: {\n                question: \"Which installation method is recommended for data science projects?\",\n                options: [\n                    \"pip install pandas\",\n                    \"conda install pandas\",\n                    \"Download from website\",\n                    \"Build from source\"\n                ],\n                correct: 1\n            }\n        }\n    },\n    importing_pandas: {\n        id: \"importing_pandas\",\n        title: \"Importing Pandas\",\n        type: \"code\",\n        content: {\n            explanation: \"Once pandas is installed, you need to import it into your Python scripts. Following standard conventions makes your code readable and maintainable.\\n\\n\\uD83D\\uDCDA **Standard Import Conventions:**\\nThe pandas community has established universal conventions for importing pandas and related libraries. Following these conventions makes your code instantly recognizable to other data analysts and developers.\\n\\n**Why 'pd' alias?**\\n• Shorter and faster to type\\n• Universal recognition in data science community\\n• Consistent with numpy ('np') and matplotlib ('plt') conventions\\n• Saves typing while maintaining code readability\\n\\n\\uD83D\\uDD27 **Import Best Practices:**\\n• Always import at the top of your script/notebook\\n• Group imports logically: standard library, third-party, local modules\\n• Use consistent aliases across all your projects\\n• Import specific functions when you only need a few operations\\n\\n⚡ **Performance Considerations:**\\n• Importing entire pandas: import pandas as pd (most common)\\n• Importing specific functions: from pandas import DataFrame, Series\\n• The specific import method can be faster for large applications\\n• But general import (as pd) is more flexible and readable\",\n            codeExample: \"**Standard Pandas Imports:**\\n\\n```python\\n# The universal standard - use this in 99% of cases\\nimport pandas as pd\\n\\n# Common data science imports - the \\\"holy trinity\\\"\\nimport pandas as pd\\nimport numpy as np\\nimport matplotlib.pyplot as plt\\n\\n# Extended data science toolkit\\nimport pandas as pd\\nimport numpy as np\\nimport matplotlib.pyplot as plt\\nimport seaborn as sns\\nfrom datetime import datetime\\n```\\n\\n**Specific Function Imports:**\\n\\n```python\\n# Import specific pandas functions (less common but useful)\\nfrom pandas import DataFrame, Series, read_csv, read_excel\\nfrom pandas import concat, merge, pivot_table\\n\\n# Create DataFrame without pd. prefix\\ndata = {'A': [1, 2, 3], 'B': [4, 5, 6]}\\ndf = DataFrame(data)  # Instead of pd.DataFrame(data)\\n```\\n\\n**Verification and Exploration:**\\n\\n```python\\nimport pandas as pd\\nimport numpy as np\\n\\n# Check what you've imported\\nprint(\\\"\\uD83D\\uDC3C Pandas version:\\\", pd.__version__)\\nprint(\\\"\\uD83D\\uDD22 NumPy version:\\\", np.__version__)\\n\\n# Explore pandas namespace\\nprint(f\\\"\\\\n\\uD83D\\uDCCA Total pandas attributes: {len(dir(pd))}\\\")\\n\\n# Key pandas components\\nprint(\\\"\\\\n\\uD83D\\uDD27 Key pandas components:\\\")\\nmain_components = ['DataFrame', 'Series', 'read_csv', 'read_excel', \\n                   'concat', 'merge', 'pivot_table', 'crosstab']\\nfor component in main_components:\\n    if hasattr(pd, component):\\n        print(f\\\"  ✅ {component}\\\")\\n```\\n\\n**Pandas Configuration:**\\n\\n```python\\n# View current pandas options\\nprint(\\\"\\\\n⚙️ Important pandas options:\\\")\\nprint(f\\\"Display max rows: {pd.get_option('display.max_rows')}\\\")\\nprint(f\\\"Display max columns: {pd.get_option('display.max_columns')}\\\")\\nprint(f\\\"Display width: {pd.get_option('display.width')}\\\")\\n\\n# Customize pandas display (optional)\\npd.set_option('display.max_columns', 10)\\npd.set_option('display.width', 1000)\\n\\n# Reset to defaults if needed\\n# pd.reset_option('all')\\n```\",\n            practicalExercise: \"\\uD83D\\uDCBB **Import Practice Exercise:**\\n\\n**Task 1: Standard Imports**\\n1. Create a new Python file or Jupyter cell\\n2. Import pandas with the standard alias\\n3. Import numpy and matplotlib with standard aliases\\n4. Print the version of each library\\n\\n**Task 2: Create and Display Data**\\n1. Create a DataFrame with this data:\\n   - Names: ['Alice', 'Bob', 'Charlie']\\n   - Ages: [25, 30, 35]  \\n   - Cities: ['NYC', 'LA', 'Chicago']\\n2. Display the DataFrame\\n3. Show the data types using df.dtypes\\n\\n**Task 3: Specific Imports**\\n1. Try importing only DataFrame and Series from pandas\\n2. Create the same data structure without using pd. prefix\\n3. Compare the two approaches\\n\\n**Task 4: Explore Pandas**\\n1. Use dir(pd) to see all available pandas functions\\n2. Find and print 5 functions that start with 'read_'\\n3. Use help(pd.DataFrame) to see DataFrame documentation\",\n            keyPoints: [\n                \"'import pandas as pd' is the universal standard - use it consistently\",\n                \"Import numpy as 'np' and matplotlib.pyplot as 'plt' for complete data science setup\",\n                \"Specific imports (from pandas import DataFrame) can be faster but less flexible\",\n                \"Always import at the top of your script for better code organization\",\n                \"Use pd.get_option() and pd.set_option() to customize pandas behavior\",\n                \"dir(pd) shows all available pandas functions and attributes\",\n                \"Following community conventions makes your code more maintainable and shareable\"\n            ],\n            quiz: {\n                question: \"What is the standard alias used when importing pandas?\",\n                options: [\n                    \"pandas\",\n                    \"pds\",\n                    \"pd\",\n                    \"pan\"\n                ],\n                correct: 2\n            }\n        }\n    },\n    intro_series: {\n        id: \"intro_series\",\n        title: \"Introduction to Series\",\n        type: \"theory\",\n        content: {\n            explanation: \"A pandas Series is a one-dimensional labeled array that can hold any data type. Think of it as a column in a spreadsheet or a single column from a database table.\\n\\n\\uD83C\\uDFAF **What is a Series?**\\nA Series is like a supercharged Python list with extra features:\\n• Labeled indices: Each value has a label (like row numbers in Excel)\\n• Homogeneous data: All values are typically the same type  \\n• Vectorized operations: Perform operations on entire series at once\\n• Built-in methods: Tons of useful functions for data analysis\\n\\n\\uD83C\\uDFD7️ **Series Structure:**\\n```\\nIndex    Values\\n-----    ------\\n  0   →   'Apple'\\n  1   →   'Banana'  \\n  2   →   'Orange'\\n  3   →   'Grape'\\n```\\n\\n\\uD83D\\uDCCA **Series vs Python List:**\\n• Python List: [10, 20, 30, 40]\\n• Pandas Series: Labeled, typed, with built-in analytics\\n\\n\\uD83D\\uDD0D **Key Components:**\\n1. **Values**: The actual data (numbers, strings, dates, etc.)\\n2. **Index**: Labels for each value (automatically generated or custom)\\n3. **Name**: Optional name for the Series\\n4. **Data Type**: The type of data stored (int64, float64, object, etc.)\\n\\n⚡ **When to Use Series:**\\n• Representing a single variable (like all ages in a dataset)\\n• Time series data (stock prices over time)\\n• Any sequence of labeled data\\n• As building blocks for DataFrames\",\n            codeExample: \"**Creating Series - Multiple Methods:**\\n\\n```python\\nimport pandas as pd\\nimport numpy as np\\n\\n# Method 1: From a Python list (most common)\\nfruits = pd.Series(['Apple', 'Banana', 'Orange', 'Grape'])\\nprint(\\\"\\uD83C\\uDF4E Fruits Series:\\\")\\nprint(fruits)\\nprint(f\\\"Type: {type(fruits)}\\\\n\\\")\\n\\n# Method 2: From a list with custom index\\nprices = pd.Series([1.50, 0.75, 2.00, 3.50], \\n                   index=['Apple', 'Banana', 'Orange', 'Grape'],\\n                   name='Fruit_Prices')\\nprint(\\\"\\uD83D\\uDCB0 Fruit Prices:\\\")\\nprint(prices)\\nprint()\\n\\n# Method 3: From a dictionary (keys become index)\\nstudent_grades = pd.Series({\\n    'Alice': 95,\\n    'Bob': 87,\\n    'Charlie': 92,\\n    'Diana': 89\\n})\\nprint(\\\"\\uD83D\\uDCCA Student Grades:\\\")\\nprint(student_grades)\\nprint()\\n\\n# Method 4: From numpy array\\nnp_array = np.array([10, 20, 30, 40, 50])\\nnumbers = pd.Series(np_array, name='Numbers')\\nprint(\\\"\\uD83D\\uDD22 Numbers Series:\\\")\\nprint(numbers)\\nprint()\\n```\\n\\n**Series Properties and Attributes:**\\n\\n```python\\nprint(\\\"\\uD83D\\uDD0D Series Properties:\\\")\\nprint(f\\\"Values: {prices.values}\\\")\\nprint(f\\\"Index: {prices.index.tolist()}\\\")\\nprint(f\\\"Name: {prices.name}\\\")\\nprint(f\\\"Data Type: {prices.dtype}\\\")\\nprint(f\\\"Shape: {prices.shape}\\\")\\nprint(f\\\"Size: {prices.size}\\\")\\nprint()\\n```\\n\\n**Basic Series Operations:**\\n\\n```python\\nprint(\\\"\\uD83D\\uDCC8 Basic Operations:\\\")\\nprint(f\\\"Maximum price: $\".concat(prices.max(), '\")\\nprint(f\"Minimum price: $').concat(prices.min(), '\")\\nprint(f\"Average price: $').concat(prices.mean(), '\")\\nprint(f\"Sum of all prices: $').concat(prices.sum(), '\")\\nprint()\\n\\n# Accessing elements\\nprint(\"\\uD83C\\uDFAF Accessing Elements:\")\\nprint(f\"Apple price: $').concat(prices[\"Apple\"], '\")\\nprint(f\"First fruit price: $').concat(prices.iloc[0], '\")  # by position\\nprint(f\"Last fruit price: $').concat(prices.iloc[-1], '\")  # last element\\nprint()\\n\\n# Boolean indexing\\nexpensive_fruits = prices[prices > 2.0]\\nprint(\"\\uD83D\\uDCB8 Expensive fruits (>$2.00):\")\\nprint(expensive_fruits)\\n```'),\n            practicalExercise: \"\\uD83C\\uDFAF **Series Creation Challenge:**\\n\\n**Exercise 1: Personal Data Series**\\nCreate three Series about yourself:\\n1. **Hobbies**: List your top 5 hobbies with custom indices (hobby1, hobby2, etc.)\\n2. **Daily Hours**: Hours spent on different activities (sleep, work, leisure, etc.)\\n3. **Favorite Numbers**: Your lucky numbers with their meanings as index\\n\\n**Exercise 2: Data Analysis**\\nUsing the daily hours Series:\\n1. Find the activity you spend most time on\\n2. Calculate total hours (should be 24!)\\n3. Find activities where you spend more than 2 hours\\n4. Create a new Series with just work-related activities\\n\\n**Exercise 3: Series from Dictionary**\\nCreate a Series representing a simple inventory:\\n- Items: ['Laptop', 'Mouse', 'Keyboard', 'Monitor']  \\n- Quantities: [5, 25, 15, 8]\\n- Calculate total items and find items with low stock (<10)\\n\\n**Bonus Challenge:**\\nCreate a time series with dates as index and random temperatures as values for one week!\",\n            keyPoints: [\n                \"Series is a 1D labeled array - like a single column with row labels\",\n                \"Can be created from lists, dictionaries, numpy arrays, or scalar values\",\n                \"Index provides meaningful labels for each value (auto-generated or custom)\",\n                \"Supports vectorized operations - apply functions to entire series at once\",\n                'Access elements by label (series[\"label\"]) or position (series.iloc[0])',\n                \"Built-in statistical methods: mean(), sum(), max(), min(), describe()\",\n                \"Series are the building blocks of DataFrames (DataFrame = multiple Series)\"\n            ],\n            quiz: {\n                question: \"What is the main difference between a pandas Series and a Python list?\",\n                options: [\n                    \"Series can only hold numbers\",\n                    \"Series has labeled indices and built-in methods\",\n                    \"Series are faster to create\",\n                    \"Series cannot be modified\"\n                ],\n                correct: 1\n            }\n        }\n    },\n    intro_dataframe: {\n        id: \"intro_dataframe\",\n        title: \"Introduction to DataFrame\",\n        type: \"theory\",\n        content: {\n            explanation: \"A DataFrame is pandas' primary data structure - a 2-dimensional labeled data structure with columns of potentially different types. Think of it as a spreadsheet or SQL table in Python.\\n\\n\\uD83C\\uDFAF **What is a DataFrame?**\\nA DataFrame is like a collection of Series that share the same index:\\n• **2D Structure**: Rows and columns like a table\\n• **Labeled Axes**: Both row (index) and column labels\\n• **Mixed Data Types**: Different columns can hold different data types\\n• **Size Mutable**: Add/remove rows and columns dynamically\\n• **Powerful Operations**: Built-in functions for data manipulation and analysis\\n\\n\\uD83C\\uDFD7️ **DataFrame Structure:**\\n```\\n         Name    Age    City       Salary\\nIndex    \\n  0   →  Alice   25   New York    70000\\n  1   →  Bob     30   London      80000  \\n  2   →  Charlie 35   Tokyo       90000\\n```\\n\\n\\uD83D\\uDCCA **Key Components:**\\n1. **Index**: Row labels (0, 1, 2... or custom labels)\\n2. **Columns**: Column names/labels  \\n3. **Values**: The actual data in a 2D numpy array\\n4. **Data Type**: Each column has its own data type\\n\\n⚡ **DataFrame vs Other Structures:**\\n• **Excel Spreadsheet**: Similar concept but DataFrame is programmable\\n• **SQL Table**: Same tabular structure with more powerful operations\\n• **R data.frame**: Pandas DataFrame inspired by R's data.frame\\n• **Dictionary of Lists**: DataFrame provides structure and methods\\n\\n\\uD83D\\uDD0D **Common Use Cases:**\\n• Storing and analyzing business data (sales, customers, products)\\n• Scientific data analysis (experiments, measurements, observations)  \\n• Financial data (stock prices, trading records, portfolios)\\n• Web analytics (user behavior, page views, conversions)\\n• Any structured data that needs analysis and manipulation\",\n            codeExample: \"**Creating DataFrames - Multiple Methods:**\\n\\n```python\\nimport pandas as pd\\nimport numpy as np\\n\\n# Method 1: From a dictionary (most common)\\nemployee_data = {\\n    'Name': ['Alice', 'Bob', 'Charlie', 'Diana'],\\n    'Age': [25, 30, 35, 28],\\n    'Department': ['Engineering', 'Marketing', 'Sales', 'HR'],\\n    'Salary': [70000, 65000, 80000, 60000],\\n    'Start_Date': ['2020-01-15', '2019-03-22', '2018-07-08', '2021-02-01']\\n}\\n\\ndf = pd.DataFrame(employee_data)\\nprint(\\\"\\uD83D\\uDC65 Employee DataFrame:\\\")\\nprint(df)\\nprint(f\\\"Shape: {df.shape} (rows, columns)\\\\n\\\")\\n\\n# Method 2: From list of dictionaries\\nsales_data = [\\n    {'Product': 'Laptop', 'Price': 999.99, 'Category': 'Electronics'},\\n    {'Product': 'Phone', 'Price': 699.99, 'Category': 'Electronics'},\\n    {'Product': 'Desk', 'Price': 299.99, 'Category': 'Furniture'}\\n]\\n\\nsales_df = pd.DataFrame(sales_data)\\nprint(\\\"\\uD83D\\uDED2 Sales DataFrame:\\\")\\nprint(sales_df)\\nprint()\\n\\n# Method 3: From numpy array with custom index and columns\\nnp_data = np.random.randint(0, 100, size=(4, 3))\\ngrades_df = pd.DataFrame(np_data, \\n                        columns=['Math', 'Science', 'English'],\\n                        index=['Alice', 'Bob', 'Charlie', 'Diana'])\\nprint(\\\"\\uD83D\\uDCDA Student Grades DataFrame:\\\")\\nprint(grades_df)\\nprint()\\n```\\n\\n**DataFrame Properties and Info:**\\n\\n```python\\nprint(\\\"\\uD83D\\uDD0D DataFrame Properties:\\\")\\nprint(f\\\"Shape: {df.shape}\\\")\\nprint(f\\\"Size (total elements): {df.size}\\\")\\nprint(f\\\"Number of dimensions: {df.ndim}\\\")\\nprint(f\\\"Column names: {df.columns.tolist()}\\\")\\nprint(f\\\"Index: {df.index.tolist()}\\\")\\nprint(f\\\"Data types:\\\\n{df.dtypes}\\\")\\nprint()\\n\\n# Detailed information about the DataFrame\\nprint(\\\"\\uD83D\\uDCCA DataFrame Info:\\\")\\ndf.info()\\nprint()\\n```\\n\\n**Basic DataFrame Operations:**\\n\\n```python\\nprint(\\\"\\uD83C\\uDFAF Basic DataFrame Operations:\\\")\\n\\n# Head and tail\\nprint(\\\"First 2 rows:\\\")\\nprint(df.head(2))\\nprint()\\n\\nprint(\\\"Last 2 rows:\\\")\\nprint(df.tail(2))\\nprint()\\n\\n# Statistical summary\\nprint(\\\"\\uD83D\\uDCC8 Statistical Summary:\\\")\\nprint(df.describe())\\nprint()\\n\\n# Access specific columns\\nprint(\\\"\\uD83D\\uDCB0 Just the salaries:\\\")\\nprint(df['Salary'])\\nprint()\\n\\n# Access multiple columns\\nprint(\\\"\\uD83D\\uDC64 Names and Ages:\\\")\\nprint(df[['Name', 'Age']])\\nprint()\\n\\n# Basic filtering\\nhigh_earners = df[df['Salary'] > 65000]\\nprint(\\\"\\uD83D\\uDCB8 High earners (>65k):\\\")\\nprint(high_earners)\\n```\",\n            practicalExercise: \"\\uD83C\\uDFAF **DataFrame Creation Challenge:**\\n\\n**Exercise 1: Personal Library**\\nCreate a DataFrame with your favorite books:\\n- Columns: 'Title', 'Author', 'Year', 'Genre', 'Rating' (1-5), 'Pages'\\n- Add at least 5 books\\n- Display the DataFrame and its basic info\\n\\n**Exercise 2: DataFrame Analysis**\\nUsing your library DataFrame:\\n1. Find books published after 2010\\n2. Calculate the average rating\\n3. Find the longest book (most pages)\\n4. Group books by genre and count them\\n5. Create a new column 'Age' (current year - publication year)\\n\\n**Exercise 3: Multiple Creation Methods**\\nCreate the same student data using three different methods:\\n1. From a dictionary\\n2. From a list of dictionaries  \\n3. From separate lists for each column\\n\\nData to use:\\n- Students: ['John', 'Sarah', 'Mike', 'Emma']\\n- Subjects: ['Math', 'Science', 'English', 'History']  \\n- Grades: [85, 92, 78, 88]\\n\\n**Exercise 4: Real-world Dataset**\\nCreate a DataFrame representing a simple e-commerce order:\\n- Order_ID, Customer_Name, Product, Quantity, Unit_Price, Total_Price\\n- Add 6-8 sample orders\\n- Calculate summary statistics\\n- Find the most expensive order\",\n            keyPoints: [\n                \"DataFrame is a 2D labeled data structure - like a spreadsheet in Python\",\n                \"Can be created from dictionaries, lists, numpy arrays, or other DataFrames\",\n                \"Each column is essentially a Series with a shared index\",\n                \"Supports mixed data types - numbers, strings, dates in different columns\",\n                'Access columns with df[\"column_name\"] or df.column_name syntax',\n                \"Use .head(), .tail(), .info(), and .describe() to explore DataFrames\",\n                \"DataFrame is the most important pandas data structure for data analysis\"\n            ],\n            quiz: {\n                question: \"How many dimensions does a pandas DataFrame have?\",\n                options: [\n                    \"1 dimension\",\n                    \"2 dimensions\",\n                    \"3 dimensions\",\n                    \"Variable dimensions\"\n                ],\n                correct: 1\n            }\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdG9waWNEYXRhLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFpQk8sTUFBTUEsWUFBNkM7SUFDeERDLGdCQUFnQjtRQUNkQyxJQUFJO1FBQ0pDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxTQUFTO1lBQ1BDLGFBQWM7WUF3QmRDLGFBQWM7WUE4QmRDLG1CQUFvQjtZQW1CcEJDLFdBQVc7Z0JBQ1Q7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUVEQyxNQUFNO2dCQUNKQyxVQUFVO2dCQUNWQyxTQUFTO29CQUNQO29CQUNBO29CQUNBO29CQUNBO2lCQUNEO2dCQUNEQyxTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBRUFDLG9CQUFvQjtRQUNsQlosSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsU0FBUztZQUNQQyxhQUFjO1lBNkJkQyxhQUFjO1lBa0RkQyxtQkFBb0I7WUF5QnBCQyxXQUFXO2dCQUNUO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0Q7WUFFREMsTUFBTTtnQkFDSkMsVUFBVTtnQkFDVkMsU0FBUztvQkFDUDtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDRDtnQkFDREMsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUVBRSxrQkFBa0I7UUFDaEJiLElBQUk7UUFDSkMsT0FBTztRQUNQQyxNQUFNO1FBQ05DLFNBQVM7WUFDUEMsYUFBYztZQXVCZEMsYUFBYztZQXNFZEMsbUJBQW9CO1lBMEJwQkMsV0FBVztnQkFDVDtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1lBRURDLE1BQU07Z0JBQ0pDLFVBQVU7Z0JBQ1ZDLFNBQVM7b0JBQUM7b0JBQVU7b0JBQU87b0JBQU07aUJBQU07Z0JBQ3ZDQyxTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBRUFHLGNBQWM7UUFDWmQsSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsU0FBUztZQUNQQyxhQUFjO1lBbUNkQyxhQUFhLHM1Q0F5RFFVLE9BREFBLE9BQU9DLEdBQUcsSUFBRyxnQ0FFYkQsT0FEQUEsT0FBT0UsR0FBRyxJQUFHLGdDQUVURixPQURKQSxPQUFPRyxJQUFJLElBQUcsb0NBTWhCSCxPQUxNQSxPQUFPSSxHQUFHLElBQUcsMEdBTWJKLE9BRE5BLE1BQU0sQ0FBQyxRQUFRLEVBQUMsb0NBRVhBLE9BRENBLE9BQU9LLElBQUksQ0FBQyxFQUFFLEVBQUMsa0RBQ0EsT0FBaEJMLE9BQU9LLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBQztZQVN4Q2QsbUJBQW9CO1lBd0JwQkMsV0FBVztnQkFDVDtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1lBRURDLE1BQU07Z0JBQ0pDLFVBQVU7Z0JBQ1ZDLFNBQVM7b0JBQ1A7b0JBQ0E7b0JBQ0E7b0JBQ0E7aUJBQ0Q7Z0JBQ0RDLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFFQVUsaUJBQWlCO1FBQ2ZyQixJQUFJO1FBQ0pDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxTQUFTO1lBQ1BDLGFBQWM7WUFzQ2RDLGFBQWM7WUErRmRDLG1CQUFvQjtZQWtDcEJDLFdBQVc7Z0JBQ1Q7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUVEQyxNQUFNO2dCQUNKQyxVQUFVO2dCQUNWQyxTQUFTO29CQUFDO29CQUFlO29CQUFnQjtvQkFBZ0I7aUJBQXNCO2dCQUMvRUMsU0FBUztZQUNYO1FBQ0Y7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi90b3BpY0RhdGEudHM/NjFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFRvcGljQ29udGVudCB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgY29udGVudDoge1xuICAgIGV4cGxhbmF0aW9uOiBzdHJpbmc7XG4gICAgY29kZUV4YW1wbGU/OiBzdHJpbmc7XG4gICAgcHJhY3RpY2FsRXhlcmNpc2U/OiBzdHJpbmc7XG4gICAga2V5UG9pbnRzOiBzdHJpbmdbXTtcbiAgICBxdWl6Pzoge1xuICAgICAgcXVlc3Rpb246IHN0cmluZztcbiAgICAgIG9wdGlvbnM6IHN0cmluZ1tdO1xuICAgICAgY29ycmVjdDogbnVtYmVyO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCB0b3BpY0RhdGE6IHsgW2tleTogc3RyaW5nXTogVG9waWNDb250ZW50IH0gPSB7XG4gIHdoYXRfaXNfcGFuZGFzOiB7XG4gICAgaWQ6ICd3aGF0X2lzX3BhbmRhcycsXG4gICAgdGl0bGU6ICdXaGF0IGlzIFBhbmRhcycsXG4gICAgdHlwZTogJ3RoZW9yeScsXG4gICAgY29udGVudDoge1xuICAgICAgZXhwbGFuYXRpb246IGBQYW5kYXMgaXMgYSBwb3dlcmZ1bCwgb3Blbi1zb3VyY2UgZGF0YSBhbmFseXNpcyBhbmQgbWFuaXB1bGF0aW9uIGxpYnJhcnkgZm9yIFB5dGhvbi4gQnVpbHQgb24gdG9wIG9mIE51bVB5LCBpdCBwcm92aWRlcyBoaWdoLXBlcmZvcm1hbmNlLCBlYXN5LXRvLXVzZSBkYXRhIHN0cnVjdHVyZXMgYW5kIGRhdGEgYW5hbHlzaXMgdG9vbHMuXG5cbvCfjq8gKipXaGF0IG1ha2VzIFBhbmRhcyBzcGVjaWFsPyoqXG5cblBhbmRhcyBzdGFuZHMgZm9yIFwiUGFuZWwgRGF0YVwiIGFuZCB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYnkgV2VzIE1jS2lubmV5IGluIDIwMDguIEl0IGhhcyBiZWNvbWUgdGhlIGNvcm5lcnN0b25lIG9mIGRhdGEgYW5hbHlzaXMgaW4gUHl0aG9uIGJlY2F1c2UgaXQgbWFrZXMgd29ya2luZyB3aXRoIHN0cnVjdHVyZWQgZGF0YSBpbnR1aXRpdmUgYW5kIGVmZmljaWVudC5cblxuKipLZXkgQ2FwYWJpbGl0aWVzOioqXG7igKIgRGF0YSBTdHJ1Y3R1cmVzOiBUd28gcHJpbWFyeSBkYXRhIHN0cnVjdHVyZXMgLSBTZXJpZXMgKDFEKSBhbmQgRGF0YUZyYW1lICgyRClcbuKAoiBEYXRhIEltcG9ydC9FeHBvcnQ6IFJlYWQgZnJvbSBDU1YsIEV4Y2VsLCBKU09OLCBTUUwgZGF0YWJhc2VzLCB3ZWIgQVBJcywgYW5kIG1vcmVcbuKAoiBEYXRhIENsZWFuaW5nOiBIYW5kbGUgbWlzc2luZyBkYXRhLCByZW1vdmUgZHVwbGljYXRlcywgdHJhbnNmb3JtIGRhdGEgdHlwZXNcbuKAoiBEYXRhIE1hbmlwdWxhdGlvbjogRmlsdGVyLCBzb3J0LCBncm91cCwgbWVyZ2UsIGFuZCByZXNoYXBlIGRhdGEgd2l0aCBlYXNlXG7igKIgU3RhdGlzdGljYWwgQW5hbHlzaXM6IEJ1aWx0LWluIHN0YXRpc3RpY2FsIGZ1bmN0aW9ucyBhbmQgdGltZSBzZXJpZXMgYW5hbHlzaXNcbuKAoiBWaXN1YWxpemF0aW9uOiBCYXNpYyBwbG90dGluZyBjYXBhYmlsaXRpZXMgd2l0aCBtYXRwbG90bGliIGludGVncmF0aW9uXG5cbioqV2h5IFBhbmRhcyBpcyBFc3NlbnRpYWw6KipcblBhbmRhcyBicmlkZ2VzIHRoZSBnYXAgYmV0d2VlbiByYXcgZGF0YSBhbmQgYW5hbHlzaXMuIEJlZm9yZSBwYW5kYXMsIHdvcmtpbmcgd2l0aCBzdHJ1Y3R1cmVkIGRhdGEgaW4gUHl0aG9uIHJlcXVpcmVkIHdyaXRpbmcgbG90cyBvZiBib2lsZXJwbGF0ZSBjb2RlLiBQYW5kYXMgcHJvdmlkZXMgaW50dWl0aXZlLCByZWFkYWJsZSBzeW50YXggdGhhdCBtYWtlcyBkYXRhIGFuYWx5c2lzIGFjY2Vzc2libGUgdG8gZXZlcnlvbmUuXG5cbioqSW5kdXN0cmllcyBVc2luZyBQYW5kYXM6KipcbuKAoiBGaW5hbmNlIC0gUmlzayBhbmFseXNpcywgcG9ydGZvbGlvIG9wdGltaXphdGlvbiwgdHJhZGluZyBhbGdvcml0aG1zXG7igKIgSGVhbHRoY2FyZSAtIFBhdGllbnQgZGF0YSBhbmFseXNpcywgbWVkaWNhbCByZXNlYXJjaCwgY2xpbmljYWwgdHJpYWxzXG7igKIgTWFya2V0aW5nIC0gQ3VzdG9tZXIgc2VnbWVudGF0aW9uLCBjYW1wYWlnbiBhbmFseXNpcywgQS9CIHRlc3RpbmcgIFxu4oCiIFRlY2hub2xvZ3kgLSBMb2cgYW5hbHlzaXMsIHVzZXIgYmVoYXZpb3IgdHJhY2tpbmcsIHN5c3RlbSBtb25pdG9yaW5nXG7igKIgUmVzZWFyY2ggLSBTY2llbnRpZmljIGRhdGEgYW5hbHlzaXMsIGFjYWRlbWljIHJlc2VhcmNoLCBkYXRhIGpvdXJuYWxpc21gLFxuXG4gICAgICBjb2RlRXhhbXBsZTogYFxcYFxcYFxcYHB5dGhvblxuIyBJbXBvcnQgcGFuZGFzIC0gdGhlIHN0YW5kYXJkIHdheVxuaW1wb3J0IHBhbmRhcyBhcyBwZFxuaW1wb3J0IG51bXB5IGFzIG5wXG5cbiMgQ3JlYXRlIHlvdXIgZmlyc3QgRGF0YUZyYW1lXG5kYXRhID0ge1xuICAgICdQcm9kdWN0JzogWydMYXB0b3AnLCAnUGhvbmUnLCAnVGFibGV0JywgJ01vbml0b3InXSxcbiAgICAnUHJpY2UnOiBbOTk5Ljk5LCA2OTkuOTksIDM5OS45OSwgMjk5Ljk5XSxcbiAgICAnQ2F0ZWdvcnknOiBbJ0VsZWN0cm9uaWNzJywgJ0VsZWN0cm9uaWNzJywgJ0VsZWN0cm9uaWNzJywgJ0VsZWN0cm9uaWNzJ10sXG4gICAgJ0luX1N0b2NrJzogW1RydWUsIFRydWUsIEZhbHNlLCBUcnVlXSxcbiAgICAnUmF0aW5nJzogWzQuNSwgNC4yLCA0LjAsIDQuOF1cbn1cblxuZGYgPSBwZC5EYXRhRnJhbWUoZGF0YSlcbnByaW50KFwiWW91ciBGaXJzdCBEYXRhRnJhbWU6XCIpXG5wcmludChkZilcbnByaW50KGZcIkRhdGFGcmFtZSBTaGFwZToge2RmLnNoYXBlfVwiKVxucHJpbnQoZlwiRGF0YSBUeXBlczpcXFxcbntkZi5kdHlwZXN9XCIpXG5cbiMgQ3JlYXRlIGEgU2VyaWVzICgxRCBkYXRhIHN0cnVjdHVyZSlcbnByaWNlcyA9IHBkLlNlcmllcyhbOTk5Ljk5LCA2OTkuOTksIDM5OS45OSwgMjk5Ljk5XSwgXG4gICAgICAgICAgICAgICAgICAgbmFtZT0nUHJpY2VzJyxcbiAgICAgICAgICAgICAgICAgICBpbmRleD1bJ0xhcHRvcCcsICdQaG9uZScsICdUYWJsZXQnLCAnTW9uaXRvciddKVxucHJpbnQoZlwiUHJpY2VzIFNlcmllczpcXFxcbntwcmljZXN9XCIpXG5cbiMgUXVpY2sgRGF0YUZyYW1lIHN0YXRpc3RpY3NcbnByaW50KGZcIlF1aWNrIFN0YXRpc3RpY3M6XFxcXG57ZGYuZGVzY3JpYmUoKX1cIilcblxcYFxcYFxcYGAsXG5cbiAgICAgIHByYWN0aWNhbEV4ZXJjaXNlOiBg8J+OryAqKllvdXIgRmlyc3QgUGFuZGFzIENoYWxsZW5nZToqKlxuXG5DcmVhdGUgYSBEYXRhRnJhbWUgYWJvdXQgeW91ciBmYXZvcml0ZSBtb3ZpZXM6XG5cbjEuIENyZWF0ZSBhIGRpY3Rpb25hcnkgd2l0aCB0aGVzZSBjb2x1bW5zOlxuICAgLSAnVGl0bGUnOiBOYW1lcyBvZiA1IG1vdmllcyB5b3UgbG92ZVxuICAgLSAnWWVhcic6IFJlbGVhc2UgeWVhcnMgIFxuICAgLSAnR2VucmUnOiBNb3ZpZSBnZW5yZXNcbiAgIC0gJ1JhdGluZyc6IFlvdXIgcGVyc29uYWwgcmF0aW5nICgxLTEwKVxuICAgLSAnV2F0Y2hlZCc6IFRydWUvRmFsc2UgaWYgeW91J3ZlIHdhdGNoZWQgcmVjZW50bHlcblxuMi4gQ29udmVydCBpdCB0byBhIERhdGFGcmFtZSB1c2luZyBwZC5EYXRhRnJhbWUoKVxuMy4gUHJpbnQgdGhlIERhdGFGcmFtZVxuNC4gUHJpbnQgdGhlIHNoYXBlIGFuZCBkYXRhIHR5cGVzXG41LiBDYWxjdWxhdGUgdGhlIGF2ZXJhZ2UgcmF0aW5nIHVzaW5nIGRmWydSYXRpbmcnXS5tZWFuKClcblxuKipCb251cyBDaGFsbGVuZ2U6KipcbkNyZWF0ZSBhIFNlcmllcyBvZiBtb3ZpZSBkaXJlY3RvcnMgYW5kIGV4cGxvcmUgaXRzIHByb3BlcnRpZXMhYCxcblxuICAgICAga2V5UG9pbnRzOiBbXG4gICAgICAgICdQYW5kYXMgaXMgYnVpbHQgb24gTnVtUHksIG1ha2luZyBpdCBmYXN0IGFuZCBlZmZpY2llbnQgZm9yIG51bWVyaWNhbCBvcGVyYXRpb25zJyxcbiAgICAgICAgJ1R3byBtYWluIGRhdGEgc3RydWN0dXJlczogU2VyaWVzICgxRCkgYW5kIERhdGFGcmFtZSAoMkQpIGhhbmRsZSBtb3N0IGRhdGEgc2NlbmFyaW9zJyxcbiAgICAgICAgJ1BhbmRhcyBleGNlbHMgYXQgZGF0YSBpbXBvcnQvZXhwb3J0IHdpdGggc3VwcG9ydCBmb3IgMTArIGZpbGUgZm9ybWF0cycsXG4gICAgICAgICdCdWlsdC1pbiBmdW5jdGlvbnMgZm9yIGRhdGEgY2xlYW5pbmcsIHRyYW5zZm9ybWF0aW9uLCBhbmQgc3RhdGlzdGljYWwgYW5hbHlzaXMnLFxuICAgICAgICAnRXNzZW50aWFsIHRvb2wgaW4gZGF0YSBzY2llbmNlIHdvcmtmbG93IC0gZnJvbSByYXcgZGF0YSB0byBpbnNpZ2h0cycsXG4gICAgICAgICdEZXZlbG9wZWQgYnkgV2VzIE1jS2lubmV5IGluIDIwMDgsIG5vdyBtYWludGFpbmVkIGJ5IGxhcmdlIG9wZW4tc291cmNlIGNvbW11bml0eScsXG4gICAgICAgICdJbnRlZ3JhdGVzIHNlYW1sZXNzbHkgd2l0aCBtYXRwbG90bGliLCBzY2lraXQtbGVhcm4sIGFuZCBvdGhlciBQeXRob24gbGlicmFyaWVzJ1xuICAgICAgXSxcblxuICAgICAgcXVpejoge1xuICAgICAgICBxdWVzdGlvbjogXCJXaGF0IGFyZSB0aGUgdHdvIHByaW1hcnkgZGF0YSBzdHJ1Y3R1cmVzIGluIHBhbmRhcz9cIixcbiAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgIFwiTGlzdCBhbmQgRGljdGlvbmFyeVwiLCBcbiAgICAgICAgICBcIlNlcmllcyBhbmQgRGF0YUZyYW1lXCIsIFxuICAgICAgICAgIFwiQXJyYXkgYW5kIE1hdHJpeFwiLCBcbiAgICAgICAgICBcIlRhYmxlIGFuZCBDb2x1bW5cIlxuICAgICAgICBdLFxuICAgICAgICBjb3JyZWN0OiAxXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGluc3RhbGxhdGlvbl9zZXR1cDoge1xuICAgIGlkOiAnaW5zdGFsbGF0aW9uX3NldHVwJyxcbiAgICB0aXRsZTogJ0luc3RhbGxhdGlvbiBhbmQgU2V0dXAnLFxuICAgIHR5cGU6ICdwcmFjdGljYWwnLFxuICAgIGNvbnRlbnQ6IHtcbiAgICAgIGV4cGxhbmF0aW9uOiBgR2V0dGluZyBwYW5kYXMgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkIHByb3Blcmx5IGlzIGNydWNpYWwgZm9yIGEgc21vb3RoIGRhdGEgYW5hbHlzaXMgZXhwZXJpZW5jZS4gTGV0J3MgZXhwbG9yZSBkaWZmZXJlbnQgaW5zdGFsbGF0aW9uIG1ldGhvZHMgYW5kIHNldCB1cCB5b3VyIGVudmlyb25tZW50LlxuXG7wn5SnICoqSW5zdGFsbGF0aW9uIE1ldGhvZHM6KipcblxuKipNZXRob2QgMTogcGlwIChQeXRob24gUGFja2FnZSBJbnN0YWxsZXIpKipcblRoZSBtb3N0IHN0cmFpZ2h0Zm9yd2FyZCBtZXRob2QgZm9yIG1vc3QgdXNlcnMuIHBpcCBjb21lcyB3aXRoIFB5dGhvbiAzLjQrIGJ5IGRlZmF1bHQuXG5cbioqTWV0aG9kIDI6IGNvbmRhIChBbmFjb25kYS9NaW5pY29uZGEpKiogUmVjb21tZW5kZWQgZm9yIGRhdGEgc2NpZW5jZSB3b3JrLiBDb25kYSBtYW5hZ2VzIGRlcGVuZGVuY2llcyBiZXR0ZXIgYW5kIGluY2x1ZGVzIG9wdGltaXplZCBudW1lcmljYWwgbGlicmFyaWVzLlxuXG4qKk1ldGhvZCAzOiBGdWxsIEFuYWNvbmRhIERpc3RyaWJ1dGlvbioqXG5Db21wbGV0ZSBkYXRhIHNjaWVuY2UgZW52aXJvbm1lbnQgd2l0aCAyNTArIHBhY2thZ2VzIHByZS1pbnN0YWxsZWQuXG5cbvCflI0gKipWZXJpZmljYXRpb24gU3RlcHM6KipcbkFmdGVyIGluc3RhbGxhdGlvbiwgYWx3YXlzIHZlcmlmeSB0aGF0IHBhbmRhcyBpcyB3b3JraW5nIGNvcnJlY3RseSBhbmQgY2hlY2sgdGhlIHZlcnNpb24uXG5cbvCfmoAgKipEZXZlbG9wbWVudCBFbnZpcm9ubWVudCBTZXR1cDoqKlxuRm9yIHRoZSBiZXN0IHBhbmRhcyBleHBlcmllbmNlLCBjb25zaWRlciBzZXR0aW5nIHVwOlxu4oCiIEp1cHl0ZXIgTm90ZWJvb2svTGFiOiBJbnRlcmFjdGl2ZSBkZXZlbG9wbWVudCBlbnZpcm9ubWVudFxu4oCiIElERSBDb25maWd1cmF0aW9uOiBWUyBDb2RlLCBQeUNoYXJtLCBvciBTcHlkZXIgd2l0aCBwYW5kYXMgc3VwcG9ydFxu4oCiIFZpcnR1YWwgRW52aXJvbm1lbnRzOiBJc29sYXRlIHlvdXIgcGFuZGFzIHByb2plY3RzXG5cbvCfk6YgKipBZGRpdGlvbmFsIFBhY2thZ2VzOioqXG5XaGlsZSBwYW5kYXMgaXMgcG93ZXJmdWwgYWxvbmUsIHRoZXNlIHBhY2thZ2VzIGVuaGFuY2UgeW91ciBkYXRhIGFuYWx5c2lzOlxu4oCiIE51bVB5OiBOdW1lcmljYWwgb3BlcmF0aW9ucyAoYXV0b21hdGljYWxseSBpbnN0YWxsZWQgd2l0aCBwYW5kYXMpXG7igKIgTWF0cGxvdGxpYjogRGF0YSB2aXN1YWxpemF0aW9uICBcbuKAoiBTZWFib3JuOiBTdGF0aXN0aWNhbCBkYXRhIHZpc3VhbGl6YXRpb25cbuKAoiBPcGVucHl4bDogRXhjZWwgZmlsZSBzdXBwb3J0XG7igKIgU1FMQWxjaGVteTogRGF0YWJhc2UgY29ubmVjdGl2aXR5YCxcblxuICAgICAgY29kZUV4YW1wbGU6IGAqKkluc3RhbGxhdGlvbiBDb21tYW5kcyAocnVuIGluIHRlcm1pbmFsL2NvbW1hbmQgcHJvbXB0KToqKlxuXG5cXGBcXGBcXGBiYXNoXG4jIE1ldGhvZCAxOiBVc2luZyBwaXBcbnBpcCBpbnN0YWxsIHBhbmRhc1xuXG4jIEluc3RhbGwgcGFuZGFzIHdpdGggYWRkaXRpb25hbCBkYXRhIHNjaWVuY2UgcGFja2FnZXNcbnBpcCBpbnN0YWxsIHBhbmRhcyBudW1weSBtYXRwbG90bGliIHNlYWJvcm4ganVweXRlciBvcGVucHl4bFxuXG4jIE1ldGhvZCAyOiBVc2luZyBjb25kYSAocmVjb21tZW5kZWQgZm9yIGRhdGEgc2NpZW5jZSlcbmNvbmRhIGluc3RhbGwgcGFuZGFzXG5cbiMgSW5zdGFsbCBmcm9tIGNvbmRhLWZvcmdlIChvZnRlbiBtb3JlIHVwLXRvLWRhdGUpXG5jb25kYSBpbnN0YWxsIC1jIGNvbmRhLWZvcmdlIHBhbmRhc1xuXG4jIE1ldGhvZCAzOiBDcmVhdGUgYSBuZXcgY29uZGEgZW52aXJvbm1lbnQgd2l0aCBwYW5kYXNcbmNvbmRhIGNyZWF0ZSAtbiBkYXRhX2FuYWx5c2lzIHB5dGhvbj0zLjkgcGFuZGFzIG51bXB5IG1hdHBsb3RsaWIganVweXRlclxuY29uZGEgYWN0aXZhdGUgZGF0YV9hbmFseXNpc1xuXG4jIFVwZ3JhZGUgZXhpc3RpbmcgcGFuZGFzIGluc3RhbGxhdGlvblxucGlwIGluc3RhbGwgLS11cGdyYWRlIHBhbmRhc1xuIyBvclxuY29uZGEgdXBkYXRlIHBhbmRhc1xuXFxgXFxgXFxgXG5cbioqVmVyaWZpY2F0aW9uIENvZGUgKHJ1biBpbiBQeXRob24pOioqXG5cblxcYFxcYFxcYHB5dGhvblxuaW1wb3J0IHBhbmRhcyBhcyBwZFxuaW1wb3J0IG51bXB5IGFzIG5wXG5pbXBvcnQgc3lzXG5cbnByaW50KFwi8J+QjSBQeXRob24gVmVyc2lvbjpcIiwgc3lzLnZlcnNpb24pXG5wcmludChcIvCfkLwgUGFuZGFzIFZlcnNpb246XCIsIHBkLl9fdmVyc2lvbl9fKVxucHJpbnQoXCLwn5SiIE51bVB5IFZlcnNpb246XCIsIG5wLl9fdmVyc2lvbl9fKVxuXG4jIFRlc3QgYmFzaWMgZnVuY3Rpb25hbGl0eVxudGVzdF9kYXRhID0geydBJzogWzEsIDIsIDNdLCAnQic6IFs0LCA1LCA2XX1cbmRmID0gcGQuRGF0YUZyYW1lKHRlc3RfZGF0YSlcbnByaW50KFwiXFxcXG7inIUgUGFuZGFzIGlzIHdvcmtpbmcgY29ycmVjdGx5IVwiKVxucHJpbnQoZGYpXG5cbiMgQ2hlY2sgYXZhaWxhYmxlIHBhbmRhcyBmdW5jdGlvbnNcbnByaW50KGZcIlxcXFxu8J+TiiBBdmFpbGFibGUgcGFuZGFzIGZ1bmN0aW9uczoge2xlbihkaXIocGQpKX0gdG90YWxcIilcblxuIyBEaXNwbGF5IHBhbmRhcyBjb25maWd1cmF0aW9uXG5wcmludChcIlxcXFxu4pqZ77iPIFBhbmRhcyBDb25maWd1cmF0aW9uOlwiKVxucGQuc2hvd192ZXJzaW9ucyhhc19qc29uPUZhbHNlKVxuXFxgXFxgXFxgYCxcblxuICAgICAgcHJhY3RpY2FsRXhlcmNpc2U6IGDwn5ug77iPICoqSW5zdGFsbGF0aW9uIFByYWN0aWNlOioqXG5cbioqU3RlcCAxOiBJbnN0YWxsIHBhbmRhcyoqXG5DaG9vc2UgeW91ciBwcmVmZXJyZWQgbWV0aG9kIGFuZCBpbnN0YWxsIHBhbmRhc1xuXG4qKlN0ZXAgMjogVmVyaWZ5IEluc3RhbGxhdGlvbioqXG5SdW4gdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHRvIGNoZWNrIGV2ZXJ5dGhpbmcgd29ya3NcblxuKipTdGVwIDM6IFNldCBVcCBZb3VyIEVudmlyb25tZW50KipcbjEuIEluc3RhbGwgSnVweXRlcjogXFxgcGlwIGluc3RhbGwganVweXRlclxcYFxuMi4gTGF1bmNoIEp1cHl0ZXI6IFxcYGp1cHl0ZXIgbm90ZWJvb2tcXGBcbjMuIENyZWF0ZSBhIG5ldyBub3RlYm9vayBjYWxsZWQgXCJQYW5kYXNfUHJhY3RpY2VcIlxuXG4qKlN0ZXAgNDogRW52aXJvbm1lbnQgVGVzdCoqXG5JbiB5b3VyIG5ldyBub3RlYm9vazpcbjEuIEltcG9ydCBwYW5kYXMgYW5kIG51bXB5XG4yLiBDcmVhdGUgYSBzbWFsbCBEYXRhRnJhbWUgd2l0aCBzYW1wbGUgZGF0YVxuMy4gUGVyZm9ybSBhIHNpbXBsZSBvcGVyYXRpb24gKGxpa2UgY2FsY3VsYXRpbmcgbWVhbilcbjQuIERpc3BsYXkgdGhlIHJlc3VsdFxuXG4qKlRyb3VibGVzaG9vdGluZyBDb21tb24gSXNzdWVzOioqXG7igKIgUGVybWlzc2lvbiBlcnJvcnM6IFRyeSBcXGBwaXAgaW5zdGFsbCAtLXVzZXIgcGFuZGFzXFxgXG7igKIgVmVyc2lvbiBjb25mbGljdHM6IFVzZSB2aXJ0dWFsIGVudmlyb25tZW50c1xu4oCiIEltcG9ydEVycm9yOiBSZXN0YXJ0IHlvdXIgUHl0aG9uIGVudmlyb25tZW50IGFmdGVyIGluc3RhbGxhdGlvbmAsXG5cbiAgICAgIGtleVBvaW50czogW1xuICAgICAgICAncGlwIGluc3RhbGwgcGFuZGFzIGlzIHRoZSBxdWlja2VzdCBtZXRob2QgZm9yIG1vc3QgdXNlcnMnLFxuICAgICAgICAnY29uZGEgaXMgcmVjb21tZW5kZWQgZm9yIGRhdGEgc2NpZW5jZSBkdWUgdG8gYmV0dGVyIGRlcGVuZGVuY3kgbWFuYWdlbWVudCcsXG4gICAgICAgICdBbHdheXMgdmVyaWZ5IGluc3RhbGxhdGlvbiBieSBpbXBvcnRpbmcgcGFuZGFzIGFuZCBjaGVja2luZyB2ZXJzaW9uJyxcbiAgICAgICAgJ0p1cHl0ZXIgTm90ZWJvb2sgcHJvdmlkZXMgZXhjZWxsZW50IGludGVyYWN0aXZlIGVudmlyb25tZW50IGZvciBwYW5kYXMnLFxuICAgICAgICAnVmlydHVhbCBlbnZpcm9ubWVudHMgcHJldmVudCBwYWNrYWdlIGNvbmZsaWN0cyBpbiBkaWZmZXJlbnQgcHJvamVjdHMnLFxuICAgICAgICAnS2VlcCBwYW5kYXMgdXBkYXRlZCB3aXRoIHJlZ3VsYXIgcGlwL2NvbmRhIHVwZ3JhZGUgY29tbWFuZHMnLFxuICAgICAgICAnSW5zdGFsbCBhZGRpdGlvbmFsIHBhY2thZ2VzIChtYXRwbG90bGliLCBzZWFib3JuKSBmb3IgY29tcGxldGUgZGF0YSBhbmFseXNpcyB0b29sa2l0J1xuICAgICAgXSxcblxuICAgICAgcXVpejoge1xuICAgICAgICBxdWVzdGlvbjogXCJXaGljaCBpbnN0YWxsYXRpb24gbWV0aG9kIGlzIHJlY29tbWVuZGVkIGZvciBkYXRhIHNjaWVuY2UgcHJvamVjdHM/XCIsXG4gICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICBcInBpcCBpbnN0YWxsIHBhbmRhc1wiLFxuICAgICAgICAgIFwiY29uZGEgaW5zdGFsbCBwYW5kYXNcIiwgXG4gICAgICAgICAgXCJEb3dubG9hZCBmcm9tIHdlYnNpdGVcIixcbiAgICAgICAgICBcIkJ1aWxkIGZyb20gc291cmNlXCJcbiAgICAgICAgXSxcbiAgICAgICAgY29ycmVjdDogMVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpbXBvcnRpbmdfcGFuZGFzOiB7XG4gICAgaWQ6ICdpbXBvcnRpbmdfcGFuZGFzJyxcbiAgICB0aXRsZTogJ0ltcG9ydGluZyBQYW5kYXMnLFxuICAgIHR5cGU6ICdjb2RlJyxcbiAgICBjb250ZW50OiB7XG4gICAgICBleHBsYW5hdGlvbjogYE9uY2UgcGFuZGFzIGlzIGluc3RhbGxlZCwgeW91IG5lZWQgdG8gaW1wb3J0IGl0IGludG8geW91ciBQeXRob24gc2NyaXB0cy4gRm9sbG93aW5nIHN0YW5kYXJkIGNvbnZlbnRpb25zIG1ha2VzIHlvdXIgY29kZSByZWFkYWJsZSBhbmQgbWFpbnRhaW5hYmxlLlxuXG7wn5OaICoqU3RhbmRhcmQgSW1wb3J0IENvbnZlbnRpb25zOioqXG5UaGUgcGFuZGFzIGNvbW11bml0eSBoYXMgZXN0YWJsaXNoZWQgdW5pdmVyc2FsIGNvbnZlbnRpb25zIGZvciBpbXBvcnRpbmcgcGFuZGFzIGFuZCByZWxhdGVkIGxpYnJhcmllcy4gRm9sbG93aW5nIHRoZXNlIGNvbnZlbnRpb25zIG1ha2VzIHlvdXIgY29kZSBpbnN0YW50bHkgcmVjb2duaXphYmxlIHRvIG90aGVyIGRhdGEgYW5hbHlzdHMgYW5kIGRldmVsb3BlcnMuXG5cbioqV2h5ICdwZCcgYWxpYXM/KipcbuKAoiBTaG9ydGVyIGFuZCBmYXN0ZXIgdG8gdHlwZVxu4oCiIFVuaXZlcnNhbCByZWNvZ25pdGlvbiBpbiBkYXRhIHNjaWVuY2UgY29tbXVuaXR5XG7igKIgQ29uc2lzdGVudCB3aXRoIG51bXB5ICgnbnAnKSBhbmQgbWF0cGxvdGxpYiAoJ3BsdCcpIGNvbnZlbnRpb25zXG7igKIgU2F2ZXMgdHlwaW5nIHdoaWxlIG1haW50YWluaW5nIGNvZGUgcmVhZGFiaWxpdHlcblxu8J+UpyAqKkltcG9ydCBCZXN0IFByYWN0aWNlczoqKlxu4oCiIEFsd2F5cyBpbXBvcnQgYXQgdGhlIHRvcCBvZiB5b3VyIHNjcmlwdC9ub3RlYm9va1xu4oCiIEdyb3VwIGltcG9ydHMgbG9naWNhbGx5OiBzdGFuZGFyZCBsaWJyYXJ5LCB0aGlyZC1wYXJ0eSwgbG9jYWwgbW9kdWxlc1xu4oCiIFVzZSBjb25zaXN0ZW50IGFsaWFzZXMgYWNyb3NzIGFsbCB5b3VyIHByb2plY3RzXG7igKIgSW1wb3J0IHNwZWNpZmljIGZ1bmN0aW9ucyB3aGVuIHlvdSBvbmx5IG5lZWQgYSBmZXcgb3BlcmF0aW9uc1xuXG7imqEgKipQZXJmb3JtYW5jZSBDb25zaWRlcmF0aW9uczoqKlxu4oCiIEltcG9ydGluZyBlbnRpcmUgcGFuZGFzOiBpbXBvcnQgcGFuZGFzIGFzIHBkIChtb3N0IGNvbW1vbilcbuKAoiBJbXBvcnRpbmcgc3BlY2lmaWMgZnVuY3Rpb25zOiBmcm9tIHBhbmRhcyBpbXBvcnQgRGF0YUZyYW1lLCBTZXJpZXNcbuKAoiBUaGUgc3BlY2lmaWMgaW1wb3J0IG1ldGhvZCBjYW4gYmUgZmFzdGVyIGZvciBsYXJnZSBhcHBsaWNhdGlvbnNcbuKAoiBCdXQgZ2VuZXJhbCBpbXBvcnQgKGFzIHBkKSBpcyBtb3JlIGZsZXhpYmxlIGFuZCByZWFkYWJsZWAsXG5cbiAgICAgIGNvZGVFeGFtcGxlOiBgKipTdGFuZGFyZCBQYW5kYXMgSW1wb3J0czoqKlxuXG5cXGBcXGBcXGBweXRob25cbiMgVGhlIHVuaXZlcnNhbCBzdGFuZGFyZCAtIHVzZSB0aGlzIGluIDk5JSBvZiBjYXNlc1xuaW1wb3J0IHBhbmRhcyBhcyBwZFxuXG4jIENvbW1vbiBkYXRhIHNjaWVuY2UgaW1wb3J0cyAtIHRoZSBcImhvbHkgdHJpbml0eVwiXG5pbXBvcnQgcGFuZGFzIGFzIHBkXG5pbXBvcnQgbnVtcHkgYXMgbnBcbmltcG9ydCBtYXRwbG90bGliLnB5cGxvdCBhcyBwbHRcblxuIyBFeHRlbmRlZCBkYXRhIHNjaWVuY2UgdG9vbGtpdFxuaW1wb3J0IHBhbmRhcyBhcyBwZFxuaW1wb3J0IG51bXB5IGFzIG5wXG5pbXBvcnQgbWF0cGxvdGxpYi5weXBsb3QgYXMgcGx0XG5pbXBvcnQgc2VhYm9ybiBhcyBzbnNcbmZyb20gZGF0ZXRpbWUgaW1wb3J0IGRhdGV0aW1lXG5cXGBcXGBcXGBcblxuKipTcGVjaWZpYyBGdW5jdGlvbiBJbXBvcnRzOioqXG5cblxcYFxcYFxcYHB5dGhvblxuIyBJbXBvcnQgc3BlY2lmaWMgcGFuZGFzIGZ1bmN0aW9ucyAobGVzcyBjb21tb24gYnV0IHVzZWZ1bClcbmZyb20gcGFuZGFzIGltcG9ydCBEYXRhRnJhbWUsIFNlcmllcywgcmVhZF9jc3YsIHJlYWRfZXhjZWxcbmZyb20gcGFuZGFzIGltcG9ydCBjb25jYXQsIG1lcmdlLCBwaXZvdF90YWJsZVxuXG4jIENyZWF0ZSBEYXRhRnJhbWUgd2l0aG91dCBwZC4gcHJlZml4XG5kYXRhID0geydBJzogWzEsIDIsIDNdLCAnQic6IFs0LCA1LCA2XX1cbmRmID0gRGF0YUZyYW1lKGRhdGEpICAjIEluc3RlYWQgb2YgcGQuRGF0YUZyYW1lKGRhdGEpXG5cXGBcXGBcXGBcblxuKipWZXJpZmljYXRpb24gYW5kIEV4cGxvcmF0aW9uOioqXG5cblxcYFxcYFxcYHB5dGhvblxuaW1wb3J0IHBhbmRhcyBhcyBwZFxuaW1wb3J0IG51bXB5IGFzIG5wXG5cbiMgQ2hlY2sgd2hhdCB5b3UndmUgaW1wb3J0ZWRcbnByaW50KFwi8J+QvCBQYW5kYXMgdmVyc2lvbjpcIiwgcGQuX192ZXJzaW9uX18pXG5wcmludChcIvCflKIgTnVtUHkgdmVyc2lvbjpcIiwgbnAuX192ZXJzaW9uX18pXG5cbiMgRXhwbG9yZSBwYW5kYXMgbmFtZXNwYWNlXG5wcmludChmXCJcXFxcbvCfk4ogVG90YWwgcGFuZGFzIGF0dHJpYnV0ZXM6IHtsZW4oZGlyKHBkKSl9XCIpXG5cbiMgS2V5IHBhbmRhcyBjb21wb25lbnRzXG5wcmludChcIlxcXFxu8J+UpyBLZXkgcGFuZGFzIGNvbXBvbmVudHM6XCIpXG5tYWluX2NvbXBvbmVudHMgPSBbJ0RhdGFGcmFtZScsICdTZXJpZXMnLCAncmVhZF9jc3YnLCAncmVhZF9leGNlbCcsIFxuICAgICAgICAgICAgICAgICAgICdjb25jYXQnLCAnbWVyZ2UnLCAncGl2b3RfdGFibGUnLCAnY3Jvc3N0YWInXVxuZm9yIGNvbXBvbmVudCBpbiBtYWluX2NvbXBvbmVudHM6XG4gICAgaWYgaGFzYXR0cihwZCwgY29tcG9uZW50KTpcbiAgICAgICAgcHJpbnQoZlwiICDinIUge2NvbXBvbmVudH1cIilcblxcYFxcYFxcYFxuXG4qKlBhbmRhcyBDb25maWd1cmF0aW9uOioqXG5cblxcYFxcYFxcYHB5dGhvblxuIyBWaWV3IGN1cnJlbnQgcGFuZGFzIG9wdGlvbnNcbnByaW50KFwiXFxcXG7impnvuI8gSW1wb3J0YW50IHBhbmRhcyBvcHRpb25zOlwiKVxucHJpbnQoZlwiRGlzcGxheSBtYXggcm93czoge3BkLmdldF9vcHRpb24oJ2Rpc3BsYXkubWF4X3Jvd3MnKX1cIilcbnByaW50KGZcIkRpc3BsYXkgbWF4IGNvbHVtbnM6IHtwZC5nZXRfb3B0aW9uKCdkaXNwbGF5Lm1heF9jb2x1bW5zJyl9XCIpXG5wcmludChmXCJEaXNwbGF5IHdpZHRoOiB7cGQuZ2V0X29wdGlvbignZGlzcGxheS53aWR0aCcpfVwiKVxuXG4jIEN1c3RvbWl6ZSBwYW5kYXMgZGlzcGxheSAob3B0aW9uYWwpXG5wZC5zZXRfb3B0aW9uKCdkaXNwbGF5Lm1heF9jb2x1bW5zJywgMTApXG5wZC5zZXRfb3B0aW9uKCdkaXNwbGF5LndpZHRoJywgMTAwMClcblxuIyBSZXNldCB0byBkZWZhdWx0cyBpZiBuZWVkZWRcbiMgcGQucmVzZXRfb3B0aW9uKCdhbGwnKVxuXFxgXFxgXFxgYCxcblxuICAgICAgcHJhY3RpY2FsRXhlcmNpc2U6IGDwn5K7ICoqSW1wb3J0IFByYWN0aWNlIEV4ZXJjaXNlOioqXG5cbioqVGFzayAxOiBTdGFuZGFyZCBJbXBvcnRzKipcbjEuIENyZWF0ZSBhIG5ldyBQeXRob24gZmlsZSBvciBKdXB5dGVyIGNlbGxcbjIuIEltcG9ydCBwYW5kYXMgd2l0aCB0aGUgc3RhbmRhcmQgYWxpYXNcbjMuIEltcG9ydCBudW1weSBhbmQgbWF0cGxvdGxpYiB3aXRoIHN0YW5kYXJkIGFsaWFzZXNcbjQuIFByaW50IHRoZSB2ZXJzaW9uIG9mIGVhY2ggbGlicmFyeVxuXG4qKlRhc2sgMjogQ3JlYXRlIGFuZCBEaXNwbGF5IERhdGEqKlxuMS4gQ3JlYXRlIGEgRGF0YUZyYW1lIHdpdGggdGhpcyBkYXRhOlxuICAgLSBOYW1lczogWydBbGljZScsICdCb2InLCAnQ2hhcmxpZSddXG4gICAtIEFnZXM6IFsyNSwgMzAsIDM1XSAgXG4gICAtIENpdGllczogWydOWUMnLCAnTEEnLCAnQ2hpY2FnbyddXG4yLiBEaXNwbGF5IHRoZSBEYXRhRnJhbWVcbjMuIFNob3cgdGhlIGRhdGEgdHlwZXMgdXNpbmcgZGYuZHR5cGVzXG5cbioqVGFzayAzOiBTcGVjaWZpYyBJbXBvcnRzKipcbjEuIFRyeSBpbXBvcnRpbmcgb25seSBEYXRhRnJhbWUgYW5kIFNlcmllcyBmcm9tIHBhbmRhc1xuMi4gQ3JlYXRlIHRoZSBzYW1lIGRhdGEgc3RydWN0dXJlIHdpdGhvdXQgdXNpbmcgcGQuIHByZWZpeFxuMy4gQ29tcGFyZSB0aGUgdHdvIGFwcHJvYWNoZXNcblxuKipUYXNrIDQ6IEV4cGxvcmUgUGFuZGFzKipcbjEuIFVzZSBkaXIocGQpIHRvIHNlZSBhbGwgYXZhaWxhYmxlIHBhbmRhcyBmdW5jdGlvbnNcbjIuIEZpbmQgYW5kIHByaW50IDUgZnVuY3Rpb25zIHRoYXQgc3RhcnQgd2l0aCAncmVhZF8nXG4zLiBVc2UgaGVscChwZC5EYXRhRnJhbWUpIHRvIHNlZSBEYXRhRnJhbWUgZG9jdW1lbnRhdGlvbmAsXG5cbiAgICAgIGtleVBvaW50czogW1xuICAgICAgICBcIidpbXBvcnQgcGFuZGFzIGFzIHBkJyBpcyB0aGUgdW5pdmVyc2FsIHN0YW5kYXJkIC0gdXNlIGl0IGNvbnNpc3RlbnRseVwiLFxuICAgICAgICBcIkltcG9ydCBudW1weSBhcyAnbnAnIGFuZCBtYXRwbG90bGliLnB5cGxvdCBhcyAncGx0JyBmb3IgY29tcGxldGUgZGF0YSBzY2llbmNlIHNldHVwXCIsXG4gICAgICAgIFwiU3BlY2lmaWMgaW1wb3J0cyAoZnJvbSBwYW5kYXMgaW1wb3J0IERhdGFGcmFtZSkgY2FuIGJlIGZhc3RlciBidXQgbGVzcyBmbGV4aWJsZVwiLFxuICAgICAgICBcIkFsd2F5cyBpbXBvcnQgYXQgdGhlIHRvcCBvZiB5b3VyIHNjcmlwdCBmb3IgYmV0dGVyIGNvZGUgb3JnYW5pemF0aW9uXCIsXG4gICAgICAgIFwiVXNlIHBkLmdldF9vcHRpb24oKSBhbmQgcGQuc2V0X29wdGlvbigpIHRvIGN1c3RvbWl6ZSBwYW5kYXMgYmVoYXZpb3JcIixcbiAgICAgICAgXCJkaXIocGQpIHNob3dzIGFsbCBhdmFpbGFibGUgcGFuZGFzIGZ1bmN0aW9ucyBhbmQgYXR0cmlidXRlc1wiLFxuICAgICAgICBcIkZvbGxvd2luZyBjb21tdW5pdHkgY29udmVudGlvbnMgbWFrZXMgeW91ciBjb2RlIG1vcmUgbWFpbnRhaW5hYmxlIGFuZCBzaGFyZWFibGVcIlxuICAgICAgXSxcblxuICAgICAgcXVpejoge1xuICAgICAgICBxdWVzdGlvbjogXCJXaGF0IGlzIHRoZSBzdGFuZGFyZCBhbGlhcyB1c2VkIHdoZW4gaW1wb3J0aW5nIHBhbmRhcz9cIixcbiAgICAgICAgb3B0aW9uczogW1wicGFuZGFzXCIsIFwicGRzXCIsIFwicGRcIiwgXCJwYW5cIl0sXG4gICAgICAgIGNvcnJlY3Q6IDJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaW50cm9fc2VyaWVzOiB7XG4gICAgaWQ6ICdpbnRyb19zZXJpZXMnLFxuICAgIHRpdGxlOiAnSW50cm9kdWN0aW9uIHRvIFNlcmllcycsXG4gICAgdHlwZTogJ3RoZW9yeScsXG4gICAgY29udGVudDoge1xuICAgICAgZXhwbGFuYXRpb246IGBBIHBhbmRhcyBTZXJpZXMgaXMgYSBvbmUtZGltZW5zaW9uYWwgbGFiZWxlZCBhcnJheSB0aGF0IGNhbiBob2xkIGFueSBkYXRhIHR5cGUuIFRoaW5rIG9mIGl0IGFzIGEgY29sdW1uIGluIGEgc3ByZWFkc2hlZXQgb3IgYSBzaW5nbGUgY29sdW1uIGZyb20gYSBkYXRhYmFzZSB0YWJsZS5cblxu8J+OryAqKldoYXQgaXMgYSBTZXJpZXM/KipcbkEgU2VyaWVzIGlzIGxpa2UgYSBzdXBlcmNoYXJnZWQgUHl0aG9uIGxpc3Qgd2l0aCBleHRyYSBmZWF0dXJlczpcbuKAoiBMYWJlbGVkIGluZGljZXM6IEVhY2ggdmFsdWUgaGFzIGEgbGFiZWwgKGxpa2Ugcm93IG51bWJlcnMgaW4gRXhjZWwpXG7igKIgSG9tb2dlbmVvdXMgZGF0YTogQWxsIHZhbHVlcyBhcmUgdHlwaWNhbGx5IHRoZSBzYW1lIHR5cGUgIFxu4oCiIFZlY3Rvcml6ZWQgb3BlcmF0aW9uczogUGVyZm9ybSBvcGVyYXRpb25zIG9uIGVudGlyZSBzZXJpZXMgYXQgb25jZVxu4oCiIEJ1aWx0LWluIG1ldGhvZHM6IFRvbnMgb2YgdXNlZnVsIGZ1bmN0aW9ucyBmb3IgZGF0YSBhbmFseXNpc1xuXG7wn4+X77iPICoqU2VyaWVzIFN0cnVjdHVyZToqKlxuXFxgXFxgXFxgXG5JbmRleCAgICBWYWx1ZXNcbi0tLS0tICAgIC0tLS0tLVxuICAwICAg4oaSICAgJ0FwcGxlJ1xuICAxICAg4oaSICAgJ0JhbmFuYScgIFxuICAyICAg4oaSICAgJ09yYW5nZSdcbiAgMyAgIOKGkiAgICdHcmFwZSdcblxcYFxcYFxcYFxuXG7wn5OKICoqU2VyaWVzIHZzIFB5dGhvbiBMaXN0OioqXG7igKIgUHl0aG9uIExpc3Q6IFsxMCwgMjAsIDMwLCA0MF1cbuKAoiBQYW5kYXMgU2VyaWVzOiBMYWJlbGVkLCB0eXBlZCwgd2l0aCBidWlsdC1pbiBhbmFseXRpY3Ncblxu8J+UjSAqKktleSBDb21wb25lbnRzOioqXG4xLiAqKlZhbHVlcyoqOiBUaGUgYWN0dWFsIGRhdGEgKG51bWJlcnMsIHN0cmluZ3MsIGRhdGVzLCBldGMuKVxuMi4gKipJbmRleCoqOiBMYWJlbHMgZm9yIGVhY2ggdmFsdWUgKGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIG9yIGN1c3RvbSlcbjMuICoqTmFtZSoqOiBPcHRpb25hbCBuYW1lIGZvciB0aGUgU2VyaWVzXG40LiAqKkRhdGEgVHlwZSoqOiBUaGUgdHlwZSBvZiBkYXRhIHN0b3JlZCAoaW50NjQsIGZsb2F0NjQsIG9iamVjdCwgZXRjLilcblxu4pqhICoqV2hlbiB0byBVc2UgU2VyaWVzOioqXG7igKIgUmVwcmVzZW50aW5nIGEgc2luZ2xlIHZhcmlhYmxlIChsaWtlIGFsbCBhZ2VzIGluIGEgZGF0YXNldClcbuKAoiBUaW1lIHNlcmllcyBkYXRhIChzdG9jayBwcmljZXMgb3ZlciB0aW1lKVxu4oCiIEFueSBzZXF1ZW5jZSBvZiBsYWJlbGVkIGRhdGFcbuKAoiBBcyBidWlsZGluZyBibG9ja3MgZm9yIERhdGFGcmFtZXNgLFxuXG4gICAgICBjb2RlRXhhbXBsZTogYCoqQ3JlYXRpbmcgU2VyaWVzIC0gTXVsdGlwbGUgTWV0aG9kczoqKlxuXG5cXGBcXGBcXGBweXRob25cbmltcG9ydCBwYW5kYXMgYXMgcGRcbmltcG9ydCBudW1weSBhcyBucFxuXG4jIE1ldGhvZCAxOiBGcm9tIGEgUHl0aG9uIGxpc3QgKG1vc3QgY29tbW9uKVxuZnJ1aXRzID0gcGQuU2VyaWVzKFsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZScsICdHcmFwZSddKVxucHJpbnQoXCLwn42OIEZydWl0cyBTZXJpZXM6XCIpXG5wcmludChmcnVpdHMpXG5wcmludChmXCJUeXBlOiB7dHlwZShmcnVpdHMpfVxcXFxuXCIpXG5cbiMgTWV0aG9kIDI6IEZyb20gYSBsaXN0IHdpdGggY3VzdG9tIGluZGV4XG5wcmljZXMgPSBwZC5TZXJpZXMoWzEuNTAsIDAuNzUsIDIuMDAsIDMuNTBdLCBcbiAgICAgICAgICAgICAgICAgICBpbmRleD1bJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnLCAnR3JhcGUnXSxcbiAgICAgICAgICAgICAgICAgICBuYW1lPSdGcnVpdF9QcmljZXMnKVxucHJpbnQoXCLwn5KwIEZydWl0IFByaWNlczpcIilcbnByaW50KHByaWNlcylcbnByaW50KClcblxuIyBNZXRob2QgMzogRnJvbSBhIGRpY3Rpb25hcnkgKGtleXMgYmVjb21lIGluZGV4KVxuc3R1ZGVudF9ncmFkZXMgPSBwZC5TZXJpZXMoe1xuICAgICdBbGljZSc6IDk1LFxuICAgICdCb2InOiA4NyxcbiAgICAnQ2hhcmxpZSc6IDkyLFxuICAgICdEaWFuYSc6IDg5XG59KVxucHJpbnQoXCLwn5OKIFN0dWRlbnQgR3JhZGVzOlwiKVxucHJpbnQoc3R1ZGVudF9ncmFkZXMpXG5wcmludCgpXG5cbiMgTWV0aG9kIDQ6IEZyb20gbnVtcHkgYXJyYXlcbm5wX2FycmF5ID0gbnAuYXJyYXkoWzEwLCAyMCwgMzAsIDQwLCA1MF0pXG5udW1iZXJzID0gcGQuU2VyaWVzKG5wX2FycmF5LCBuYW1lPSdOdW1iZXJzJylcbnByaW50KFwi8J+UoiBOdW1iZXJzIFNlcmllczpcIilcbnByaW50KG51bWJlcnMpXG5wcmludCgpXG5cXGBcXGBcXGBcblxuKipTZXJpZXMgUHJvcGVydGllcyBhbmQgQXR0cmlidXRlczoqKlxuXG5cXGBcXGBcXGBweXRob25cbnByaW50KFwi8J+UjSBTZXJpZXMgUHJvcGVydGllczpcIilcbnByaW50KGZcIlZhbHVlczoge3ByaWNlcy52YWx1ZXN9XCIpXG5wcmludChmXCJJbmRleDoge3ByaWNlcy5pbmRleC50b2xpc3QoKX1cIilcbnByaW50KGZcIk5hbWU6IHtwcmljZXMubmFtZX1cIilcbnByaW50KGZcIkRhdGEgVHlwZToge3ByaWNlcy5kdHlwZX1cIilcbnByaW50KGZcIlNoYXBlOiB7cHJpY2VzLnNoYXBlfVwiKVxucHJpbnQoZlwiU2l6ZToge3ByaWNlcy5zaXplfVwiKVxucHJpbnQoKVxuXFxgXFxgXFxgXG5cbioqQmFzaWMgU2VyaWVzIE9wZXJhdGlvbnM6KipcblxuXFxgXFxgXFxgcHl0aG9uXG5wcmludChcIvCfk4ggQmFzaWMgT3BlcmF0aW9uczpcIilcbnByaW50KGZcIk1heGltdW0gcHJpY2U6IFxcJCR7cHJpY2VzLm1heCgpfVwiKVxucHJpbnQoZlwiTWluaW11bSBwcmljZTogXFwkJHtwcmljZXMubWluKCl9XCIpXG5wcmludChmXCJBdmVyYWdlIHByaWNlOiBcXCQke3ByaWNlcy5tZWFuKCl9XCIpXG5wcmludChmXCJTdW0gb2YgYWxsIHByaWNlczogXFwkJHtwcmljZXMuc3VtKCl9XCIpXG5wcmludCgpXG5cbiMgQWNjZXNzaW5nIGVsZW1lbnRzXG5wcmludChcIvCfjq8gQWNjZXNzaW5nIEVsZW1lbnRzOlwiKVxucHJpbnQoZlwiQXBwbGUgcHJpY2U6IFxcJCR7cHJpY2VzWydBcHBsZSddfVwiKVxucHJpbnQoZlwiRmlyc3QgZnJ1aXQgcHJpY2U6IFxcJCR7cHJpY2VzLmlsb2NbMF19XCIpICAjIGJ5IHBvc2l0aW9uXG5wcmludChmXCJMYXN0IGZydWl0IHByaWNlOiBcXCQke3ByaWNlcy5pbG9jWy0xXX1cIikgICMgbGFzdCBlbGVtZW50XG5wcmludCgpXG5cbiMgQm9vbGVhbiBpbmRleGluZ1xuZXhwZW5zaXZlX2ZydWl0cyA9IHByaWNlc1twcmljZXMgPiAyLjBdXG5wcmludChcIvCfkrggRXhwZW5zaXZlIGZydWl0cyAoPlxcJDIuMDApOlwiKVxucHJpbnQoZXhwZW5zaXZlX2ZydWl0cylcblxcYFxcYFxcYGAsXG5cbiAgICAgIHByYWN0aWNhbEV4ZXJjaXNlOiBg8J+OryAqKlNlcmllcyBDcmVhdGlvbiBDaGFsbGVuZ2U6KipcblxuKipFeGVyY2lzZSAxOiBQZXJzb25hbCBEYXRhIFNlcmllcyoqXG5DcmVhdGUgdGhyZWUgU2VyaWVzIGFib3V0IHlvdXJzZWxmOlxuMS4gKipIb2JiaWVzKio6IExpc3QgeW91ciB0b3AgNSBob2JiaWVzIHdpdGggY3VzdG9tIGluZGljZXMgKGhvYmJ5MSwgaG9iYnkyLCBldGMuKVxuMi4gKipEYWlseSBIb3VycyoqOiBIb3VycyBzcGVudCBvbiBkaWZmZXJlbnQgYWN0aXZpdGllcyAoc2xlZXAsIHdvcmssIGxlaXN1cmUsIGV0Yy4pXG4zLiAqKkZhdm9yaXRlIE51bWJlcnMqKjogWW91ciBsdWNreSBudW1iZXJzIHdpdGggdGhlaXIgbWVhbmluZ3MgYXMgaW5kZXhcblxuKipFeGVyY2lzZSAyOiBEYXRhIEFuYWx5c2lzKipcblVzaW5nIHRoZSBkYWlseSBob3VycyBTZXJpZXM6XG4xLiBGaW5kIHRoZSBhY3Rpdml0eSB5b3Ugc3BlbmQgbW9zdCB0aW1lIG9uXG4yLiBDYWxjdWxhdGUgdG90YWwgaG91cnMgKHNob3VsZCBiZSAyNCEpXG4zLiBGaW5kIGFjdGl2aXRpZXMgd2hlcmUgeW91IHNwZW5kIG1vcmUgdGhhbiAyIGhvdXJzXG40LiBDcmVhdGUgYSBuZXcgU2VyaWVzIHdpdGgganVzdCB3b3JrLXJlbGF0ZWQgYWN0aXZpdGllc1xuXG4qKkV4ZXJjaXNlIDM6IFNlcmllcyBmcm9tIERpY3Rpb25hcnkqKlxuQ3JlYXRlIGEgU2VyaWVzIHJlcHJlc2VudGluZyBhIHNpbXBsZSBpbnZlbnRvcnk6XG4tIEl0ZW1zOiBbJ0xhcHRvcCcsICdNb3VzZScsICdLZXlib2FyZCcsICdNb25pdG9yJ10gIFxuLSBRdWFudGl0aWVzOiBbNSwgMjUsIDE1LCA4XVxuLSBDYWxjdWxhdGUgdG90YWwgaXRlbXMgYW5kIGZpbmQgaXRlbXMgd2l0aCBsb3cgc3RvY2sgKDwxMClcblxuKipCb251cyBDaGFsbGVuZ2U6KipcbkNyZWF0ZSBhIHRpbWUgc2VyaWVzIHdpdGggZGF0ZXMgYXMgaW5kZXggYW5kIHJhbmRvbSB0ZW1wZXJhdHVyZXMgYXMgdmFsdWVzIGZvciBvbmUgd2VlayFgLFxuXG4gICAgICBrZXlQb2ludHM6IFtcbiAgICAgICAgJ1NlcmllcyBpcyBhIDFEIGxhYmVsZWQgYXJyYXkgLSBsaWtlIGEgc2luZ2xlIGNvbHVtbiB3aXRoIHJvdyBsYWJlbHMnLFxuICAgICAgICAnQ2FuIGJlIGNyZWF0ZWQgZnJvbSBsaXN0cywgZGljdGlvbmFyaWVzLCBudW1weSBhcnJheXMsIG9yIHNjYWxhciB2YWx1ZXMnLFxuICAgICAgICAnSW5kZXggcHJvdmlkZXMgbWVhbmluZ2Z1bCBsYWJlbHMgZm9yIGVhY2ggdmFsdWUgKGF1dG8tZ2VuZXJhdGVkIG9yIGN1c3RvbSknLFxuICAgICAgICAnU3VwcG9ydHMgdmVjdG9yaXplZCBvcGVyYXRpb25zIC0gYXBwbHkgZnVuY3Rpb25zIHRvIGVudGlyZSBzZXJpZXMgYXQgb25jZScsXG4gICAgICAgICdBY2Nlc3MgZWxlbWVudHMgYnkgbGFiZWwgKHNlcmllc1tcImxhYmVsXCJdKSBvciBwb3NpdGlvbiAoc2VyaWVzLmlsb2NbMF0pJyxcbiAgICAgICAgJ0J1aWx0LWluIHN0YXRpc3RpY2FsIG1ldGhvZHM6IG1lYW4oKSwgc3VtKCksIG1heCgpLCBtaW4oKSwgZGVzY3JpYmUoKScsXG4gICAgICAgICdTZXJpZXMgYXJlIHRoZSBidWlsZGluZyBibG9ja3Mgb2YgRGF0YUZyYW1lcyAoRGF0YUZyYW1lID0gbXVsdGlwbGUgU2VyaWVzKSdcbiAgICAgIF0sXG5cbiAgICAgIHF1aXo6IHtcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCBpcyB0aGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYSBwYW5kYXMgU2VyaWVzIGFuZCBhIFB5dGhvbiBsaXN0P1wiLFxuICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgXCJTZXJpZXMgY2FuIG9ubHkgaG9sZCBudW1iZXJzXCIsXG4gICAgICAgICAgXCJTZXJpZXMgaGFzIGxhYmVsZWQgaW5kaWNlcyBhbmQgYnVpbHQtaW4gbWV0aG9kc1wiLCBcbiAgICAgICAgICBcIlNlcmllcyBhcmUgZmFzdGVyIHRvIGNyZWF0ZVwiLFxuICAgICAgICAgIFwiU2VyaWVzIGNhbm5vdCBiZSBtb2RpZmllZFwiXG4gICAgICAgIF0sXG4gICAgICAgIGNvcnJlY3Q6IDFcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaW50cm9fZGF0YWZyYW1lOiB7XG4gICAgaWQ6ICdpbnRyb19kYXRhZnJhbWUnLFxuICAgIHRpdGxlOiAnSW50cm9kdWN0aW9uIHRvIERhdGFGcmFtZScsXG4gICAgdHlwZTogJ3RoZW9yeScsXG4gICAgY29udGVudDoge1xuICAgICAgZXhwbGFuYXRpb246IGBBIERhdGFGcmFtZSBpcyBwYW5kYXMnIHByaW1hcnkgZGF0YSBzdHJ1Y3R1cmUgLSBhIDItZGltZW5zaW9uYWwgbGFiZWxlZCBkYXRhIHN0cnVjdHVyZSB3aXRoIGNvbHVtbnMgb2YgcG90ZW50aWFsbHkgZGlmZmVyZW50IHR5cGVzLiBUaGluayBvZiBpdCBhcyBhIHNwcmVhZHNoZWV0IG9yIFNRTCB0YWJsZSBpbiBQeXRob24uXG5cbvCfjq8gKipXaGF0IGlzIGEgRGF0YUZyYW1lPyoqXG5BIERhdGFGcmFtZSBpcyBsaWtlIGEgY29sbGVjdGlvbiBvZiBTZXJpZXMgdGhhdCBzaGFyZSB0aGUgc2FtZSBpbmRleDpcbuKAoiAqKjJEIFN0cnVjdHVyZSoqOiBSb3dzIGFuZCBjb2x1bW5zIGxpa2UgYSB0YWJsZVxu4oCiICoqTGFiZWxlZCBBeGVzKio6IEJvdGggcm93IChpbmRleCkgYW5kIGNvbHVtbiBsYWJlbHNcbuKAoiAqKk1peGVkIERhdGEgVHlwZXMqKjogRGlmZmVyZW50IGNvbHVtbnMgY2FuIGhvbGQgZGlmZmVyZW50IGRhdGEgdHlwZXNcbuKAoiAqKlNpemUgTXV0YWJsZSoqOiBBZGQvcmVtb3ZlIHJvd3MgYW5kIGNvbHVtbnMgZHluYW1pY2FsbHlcbuKAoiAqKlBvd2VyZnVsIE9wZXJhdGlvbnMqKjogQnVpbHQtaW4gZnVuY3Rpb25zIGZvciBkYXRhIG1hbmlwdWxhdGlvbiBhbmQgYW5hbHlzaXNcblxu8J+Pl++4jyAqKkRhdGFGcmFtZSBTdHJ1Y3R1cmU6KipcblxcYFxcYFxcYFxuICAgICAgICAgTmFtZSAgICBBZ2UgICAgQ2l0eSAgICAgICBTYWxhcnlcbkluZGV4ICAgIFxuICAwICAg4oaSICBBbGljZSAgIDI1ICAgTmV3IFlvcmsgICAgNzAwMDBcbiAgMSAgIOKGkiAgQm9iICAgICAzMCAgIExvbmRvbiAgICAgIDgwMDAwICBcbiAgMiAgIOKGkiAgQ2hhcmxpZSAzNSAgIFRva3lvICAgICAgIDkwMDAwXG5cXGBcXGBcXGBcblxu8J+TiiAqKktleSBDb21wb25lbnRzOioqXG4xLiAqKkluZGV4Kio6IFJvdyBsYWJlbHMgKDAsIDEsIDIuLi4gb3IgY3VzdG9tIGxhYmVscylcbjIuICoqQ29sdW1ucyoqOiBDb2x1bW4gbmFtZXMvbGFiZWxzICBcbjMuICoqVmFsdWVzKio6IFRoZSBhY3R1YWwgZGF0YSBpbiBhIDJEIG51bXB5IGFycmF5XG40LiAqKkRhdGEgVHlwZSoqOiBFYWNoIGNvbHVtbiBoYXMgaXRzIG93biBkYXRhIHR5cGVcblxu4pqhICoqRGF0YUZyYW1lIHZzIE90aGVyIFN0cnVjdHVyZXM6KipcbuKAoiAqKkV4Y2VsIFNwcmVhZHNoZWV0Kio6IFNpbWlsYXIgY29uY2VwdCBidXQgRGF0YUZyYW1lIGlzIHByb2dyYW1tYWJsZVxu4oCiICoqU1FMIFRhYmxlKio6IFNhbWUgdGFidWxhciBzdHJ1Y3R1cmUgd2l0aCBtb3JlIHBvd2VyZnVsIG9wZXJhdGlvbnNcbuKAoiAqKlIgZGF0YS5mcmFtZSoqOiBQYW5kYXMgRGF0YUZyYW1lIGluc3BpcmVkIGJ5IFIncyBkYXRhLmZyYW1lXG7igKIgKipEaWN0aW9uYXJ5IG9mIExpc3RzKio6IERhdGFGcmFtZSBwcm92aWRlcyBzdHJ1Y3R1cmUgYW5kIG1ldGhvZHNcblxu8J+UjSAqKkNvbW1vbiBVc2UgQ2FzZXM6KipcbuKAoiBTdG9yaW5nIGFuZCBhbmFseXppbmcgYnVzaW5lc3MgZGF0YSAoc2FsZXMsIGN1c3RvbWVycywgcHJvZHVjdHMpXG7igKIgU2NpZW50aWZpYyBkYXRhIGFuYWx5c2lzIChleHBlcmltZW50cywgbWVhc3VyZW1lbnRzLCBvYnNlcnZhdGlvbnMpICBcbuKAoiBGaW5hbmNpYWwgZGF0YSAoc3RvY2sgcHJpY2VzLCB0cmFkaW5nIHJlY29yZHMsIHBvcnRmb2xpb3MpXG7igKIgV2ViIGFuYWx5dGljcyAodXNlciBiZWhhdmlvciwgcGFnZSB2aWV3cywgY29udmVyc2lvbnMpXG7igKIgQW55IHN0cnVjdHVyZWQgZGF0YSB0aGF0IG5lZWRzIGFuYWx5c2lzIGFuZCBtYW5pcHVsYXRpb25gLFxuXG4gICAgICBjb2RlRXhhbXBsZTogYCoqQ3JlYXRpbmcgRGF0YUZyYW1lcyAtIE11bHRpcGxlIE1ldGhvZHM6KipcblxuXFxgXFxgXFxgcHl0aG9uXG5pbXBvcnQgcGFuZGFzIGFzIHBkXG5pbXBvcnQgbnVtcHkgYXMgbnBcblxuIyBNZXRob2QgMTogRnJvbSBhIGRpY3Rpb25hcnkgKG1vc3QgY29tbW9uKVxuZW1wbG95ZWVfZGF0YSA9IHtcbiAgICAnTmFtZSc6IFsnQWxpY2UnLCAnQm9iJywgJ0NoYXJsaWUnLCAnRGlhbmEnXSxcbiAgICAnQWdlJzogWzI1LCAzMCwgMzUsIDI4XSxcbiAgICAnRGVwYXJ0bWVudCc6IFsnRW5naW5lZXJpbmcnLCAnTWFya2V0aW5nJywgJ1NhbGVzJywgJ0hSJ10sXG4gICAgJ1NhbGFyeSc6IFs3MDAwMCwgNjUwMDAsIDgwMDAwLCA2MDAwMF0sXG4gICAgJ1N0YXJ0X0RhdGUnOiBbJzIwMjAtMDEtMTUnLCAnMjAxOS0wMy0yMicsICcyMDE4LTA3LTA4JywgJzIwMjEtMDItMDEnXVxufVxuXG5kZiA9IHBkLkRhdGFGcmFtZShlbXBsb3llZV9kYXRhKVxucHJpbnQoXCLwn5GlIEVtcGxveWVlIERhdGFGcmFtZTpcIilcbnByaW50KGRmKVxucHJpbnQoZlwiU2hhcGU6IHtkZi5zaGFwZX0gKHJvd3MsIGNvbHVtbnMpXFxcXG5cIilcblxuIyBNZXRob2QgMjogRnJvbSBsaXN0IG9mIGRpY3Rpb25hcmllc1xuc2FsZXNfZGF0YSA9IFtcbiAgICB7J1Byb2R1Y3QnOiAnTGFwdG9wJywgJ1ByaWNlJzogOTk5Ljk5LCAnQ2F0ZWdvcnknOiAnRWxlY3Ryb25pY3MnfSxcbiAgICB7J1Byb2R1Y3QnOiAnUGhvbmUnLCAnUHJpY2UnOiA2OTkuOTksICdDYXRlZ29yeSc6ICdFbGVjdHJvbmljcyd9LFxuICAgIHsnUHJvZHVjdCc6ICdEZXNrJywgJ1ByaWNlJzogMjk5Ljk5LCAnQ2F0ZWdvcnknOiAnRnVybml0dXJlJ31cbl1cblxuc2FsZXNfZGYgPSBwZC5EYXRhRnJhbWUoc2FsZXNfZGF0YSlcbnByaW50KFwi8J+bkiBTYWxlcyBEYXRhRnJhbWU6XCIpXG5wcmludChzYWxlc19kZilcbnByaW50KClcblxuIyBNZXRob2QgMzogRnJvbSBudW1weSBhcnJheSB3aXRoIGN1c3RvbSBpbmRleCBhbmQgY29sdW1uc1xubnBfZGF0YSA9IG5wLnJhbmRvbS5yYW5kaW50KDAsIDEwMCwgc2l6ZT0oNCwgMykpXG5ncmFkZXNfZGYgPSBwZC5EYXRhRnJhbWUobnBfZGF0YSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPVsnTWF0aCcsICdTY2llbmNlJywgJ0VuZ2xpc2gnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4PVsnQWxpY2UnLCAnQm9iJywgJ0NoYXJsaWUnLCAnRGlhbmEnXSlcbnByaW50KFwi8J+TmiBTdHVkZW50IEdyYWRlcyBEYXRhRnJhbWU6XCIpXG5wcmludChncmFkZXNfZGYpXG5wcmludCgpXG5cXGBcXGBcXGBcblxuKipEYXRhRnJhbWUgUHJvcGVydGllcyBhbmQgSW5mbzoqKlxuXG5cXGBcXGBcXGBweXRob25cbnByaW50KFwi8J+UjSBEYXRhRnJhbWUgUHJvcGVydGllczpcIilcbnByaW50KGZcIlNoYXBlOiB7ZGYuc2hhcGV9XCIpXG5wcmludChmXCJTaXplICh0b3RhbCBlbGVtZW50cyk6IHtkZi5zaXplfVwiKVxucHJpbnQoZlwiTnVtYmVyIG9mIGRpbWVuc2lvbnM6IHtkZi5uZGltfVwiKVxucHJpbnQoZlwiQ29sdW1uIG5hbWVzOiB7ZGYuY29sdW1ucy50b2xpc3QoKX1cIilcbnByaW50KGZcIkluZGV4OiB7ZGYuaW5kZXgudG9saXN0KCl9XCIpXG5wcmludChmXCJEYXRhIHR5cGVzOlxcXFxue2RmLmR0eXBlc31cIilcbnByaW50KClcblxuIyBEZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgRGF0YUZyYW1lXG5wcmludChcIvCfk4ogRGF0YUZyYW1lIEluZm86XCIpXG5kZi5pbmZvKClcbnByaW50KClcblxcYFxcYFxcYFxuXG4qKkJhc2ljIERhdGFGcmFtZSBPcGVyYXRpb25zOioqXG5cblxcYFxcYFxcYHB5dGhvblxucHJpbnQoXCLwn46vIEJhc2ljIERhdGFGcmFtZSBPcGVyYXRpb25zOlwiKVxuXG4jIEhlYWQgYW5kIHRhaWxcbnByaW50KFwiRmlyc3QgMiByb3dzOlwiKVxucHJpbnQoZGYuaGVhZCgyKSlcbnByaW50KClcblxucHJpbnQoXCJMYXN0IDIgcm93czpcIilcbnByaW50KGRmLnRhaWwoMikpXG5wcmludCgpXG5cbiMgU3RhdGlzdGljYWwgc3VtbWFyeVxucHJpbnQoXCLwn5OIIFN0YXRpc3RpY2FsIFN1bW1hcnk6XCIpXG5wcmludChkZi5kZXNjcmliZSgpKVxucHJpbnQoKVxuXG4jIEFjY2VzcyBzcGVjaWZpYyBjb2x1bW5zXG5wcmludChcIvCfkrAgSnVzdCB0aGUgc2FsYXJpZXM6XCIpXG5wcmludChkZlsnU2FsYXJ5J10pXG5wcmludCgpXG5cbiMgQWNjZXNzIG11bHRpcGxlIGNvbHVtbnNcbnByaW50KFwi8J+RpCBOYW1lcyBhbmQgQWdlczpcIilcbnByaW50KGRmW1snTmFtZScsICdBZ2UnXV0pXG5wcmludCgpXG5cbiMgQmFzaWMgZmlsdGVyaW5nXG5oaWdoX2Vhcm5lcnMgPSBkZltkZlsnU2FsYXJ5J10gPiA2NTAwMF1cbnByaW50KFwi8J+SuCBIaWdoIGVhcm5lcnMgKD42NWspOlwiKVxucHJpbnQoaGlnaF9lYXJuZXJzKVxuXFxgXFxgXFxgYCxcblxuICAgICAgcHJhY3RpY2FsRXhlcmNpc2U6IGDwn46vICoqRGF0YUZyYW1lIENyZWF0aW9uIENoYWxsZW5nZToqKlxuXG4qKkV4ZXJjaXNlIDE6IFBlcnNvbmFsIExpYnJhcnkqKlxuQ3JlYXRlIGEgRGF0YUZyYW1lIHdpdGggeW91ciBmYXZvcml0ZSBib29rczpcbi0gQ29sdW1uczogJ1RpdGxlJywgJ0F1dGhvcicsICdZZWFyJywgJ0dlbnJlJywgJ1JhdGluZycgKDEtNSksICdQYWdlcydcbi0gQWRkIGF0IGxlYXN0IDUgYm9va3Ncbi0gRGlzcGxheSB0aGUgRGF0YUZyYW1lIGFuZCBpdHMgYmFzaWMgaW5mb1xuXG4qKkV4ZXJjaXNlIDI6IERhdGFGcmFtZSBBbmFseXNpcyoqXG5Vc2luZyB5b3VyIGxpYnJhcnkgRGF0YUZyYW1lOlxuMS4gRmluZCBib29rcyBwdWJsaXNoZWQgYWZ0ZXIgMjAxMFxuMi4gQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIHJhdGluZ1xuMy4gRmluZCB0aGUgbG9uZ2VzdCBib29rIChtb3N0IHBhZ2VzKVxuNC4gR3JvdXAgYm9va3MgYnkgZ2VucmUgYW5kIGNvdW50IHRoZW1cbjUuIENyZWF0ZSBhIG5ldyBjb2x1bW4gJ0FnZScgKGN1cnJlbnQgeWVhciAtIHB1YmxpY2F0aW9uIHllYXIpXG5cbioqRXhlcmNpc2UgMzogTXVsdGlwbGUgQ3JlYXRpb24gTWV0aG9kcyoqXG5DcmVhdGUgdGhlIHNhbWUgc3R1ZGVudCBkYXRhIHVzaW5nIHRocmVlIGRpZmZlcmVudCBtZXRob2RzOlxuMS4gRnJvbSBhIGRpY3Rpb25hcnlcbjIuIEZyb20gYSBsaXN0IG9mIGRpY3Rpb25hcmllcyAgXG4zLiBGcm9tIHNlcGFyYXRlIGxpc3RzIGZvciBlYWNoIGNvbHVtblxuXG5EYXRhIHRvIHVzZTpcbi0gU3R1ZGVudHM6IFsnSm9obicsICdTYXJhaCcsICdNaWtlJywgJ0VtbWEnXVxuLSBTdWJqZWN0czogWydNYXRoJywgJ1NjaWVuY2UnLCAnRW5nbGlzaCcsICdIaXN0b3J5J10gIFxuLSBHcmFkZXM6IFs4NSwgOTIsIDc4LCA4OF1cblxuKipFeGVyY2lzZSA0OiBSZWFsLXdvcmxkIERhdGFzZXQqKlxuQ3JlYXRlIGEgRGF0YUZyYW1lIHJlcHJlc2VudGluZyBhIHNpbXBsZSBlLWNvbW1lcmNlIG9yZGVyOlxuLSBPcmRlcl9JRCwgQ3VzdG9tZXJfTmFtZSwgUHJvZHVjdCwgUXVhbnRpdHksIFVuaXRfUHJpY2UsIFRvdGFsX1ByaWNlXG4tIEFkZCA2LTggc2FtcGxlIG9yZGVyc1xuLSBDYWxjdWxhdGUgc3VtbWFyeSBzdGF0aXN0aWNzXG4tIEZpbmQgdGhlIG1vc3QgZXhwZW5zaXZlIG9yZGVyYCxcblxuICAgICAga2V5UG9pbnRzOiBbXG4gICAgICAgICdEYXRhRnJhbWUgaXMgYSAyRCBsYWJlbGVkIGRhdGEgc3RydWN0dXJlIC0gbGlrZSBhIHNwcmVhZHNoZWV0IGluIFB5dGhvbicsXG4gICAgICAgICdDYW4gYmUgY3JlYXRlZCBmcm9tIGRpY3Rpb25hcmllcywgbGlzdHMsIG51bXB5IGFycmF5cywgb3Igb3RoZXIgRGF0YUZyYW1lcycsXG4gICAgICAgICdFYWNoIGNvbHVtbiBpcyBlc3NlbnRpYWxseSBhIFNlcmllcyB3aXRoIGEgc2hhcmVkIGluZGV4JyxcbiAgICAgICAgJ1N1cHBvcnRzIG1peGVkIGRhdGEgdHlwZXMgLSBudW1iZXJzLCBzdHJpbmdzLCBkYXRlcyBpbiBkaWZmZXJlbnQgY29sdW1ucycsXG4gICAgICAgICdBY2Nlc3MgY29sdW1ucyB3aXRoIGRmW1wiY29sdW1uX25hbWVcIl0gb3IgZGYuY29sdW1uX25hbWUgc3ludGF4JyxcbiAgICAgICAgJ1VzZSAuaGVhZCgpLCAudGFpbCgpLCAuaW5mbygpLCBhbmQgLmRlc2NyaWJlKCkgdG8gZXhwbG9yZSBEYXRhRnJhbWVzJyxcbiAgICAgICAgJ0RhdGFGcmFtZSBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgcGFuZGFzIGRhdGEgc3RydWN0dXJlIGZvciBkYXRhIGFuYWx5c2lzJ1xuICAgICAgXSxcblxuICAgICAgcXVpejoge1xuICAgICAgICBxdWVzdGlvbjogXCJIb3cgbWFueSBkaW1lbnNpb25zIGRvZXMgYSBwYW5kYXMgRGF0YUZyYW1lIGhhdmU/XCIsXG4gICAgICAgIG9wdGlvbnM6IFtcIjEgZGltZW5zaW9uXCIsIFwiMiBkaW1lbnNpb25zXCIsIFwiMyBkaW1lbnNpb25zXCIsIFwiVmFyaWFibGUgZGltZW5zaW9uc1wiXSxcbiAgICAgICAgY29ycmVjdDogMVxuICAgICAgfVxuICAgIH1cbiAgfVxufTsiXSwibmFtZXMiOlsidG9waWNEYXRhIiwid2hhdF9pc19wYW5kYXMiLCJpZCIsInRpdGxlIiwidHlwZSIsImNvbnRlbnQiLCJleHBsYW5hdGlvbiIsImNvZGVFeGFtcGxlIiwicHJhY3RpY2FsRXhlcmNpc2UiLCJrZXlQb2ludHMiLCJxdWl6IiwicXVlc3Rpb24iLCJvcHRpb25zIiwiY29ycmVjdCIsImluc3RhbGxhdGlvbl9zZXR1cCIsImltcG9ydGluZ19wYW5kYXMiLCJpbnRyb19zZXJpZXMiLCJwcmljZXMiLCJtYXgiLCJtaW4iLCJtZWFuIiwic3VtIiwiaWxvYyIsImludHJvX2RhdGFmcmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/topicData.ts\n"));

/***/ })

});